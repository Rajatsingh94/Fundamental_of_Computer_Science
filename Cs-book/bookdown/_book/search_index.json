[
["Pano.html", "Fundamental of Computer Science 1 Panormic View of Computer Science 1.1 Facets Of Computer Science 1.2 Classes of Computers 1.3 System Software 1.4 Embedded Software 1.5 Application Software 1.6 Overview of Programming Languages 1.7 Programming paradigms 1.8 Abstract Machine Hierarchy 1.9 Chapter Summary", " Fundamental of Computer Science Venkat N. Gudivada 1 Panormic View of Computer Science Computer Science has been one of the fastest grown disciplines during the last few decades. The growth and innovation has been phenomenal. Computing power that was encased into multi- million dollar, mammoth size IBM Mainframe computers of the 1960s is made available today in laptop computers. Advent of the World-Wide Web (WWW) in 1993 has spurred even more interest in computers and indeed they have become a household name. It is quite uncommon not to find a computer on the desks of employees of organizations. Productivity software such as word processors and spreadsheets that run on these desktop computers has become a commodity item. Computers have become an integral part of our personal and societal life directly and indirectly. They are being used for tasks ranging from home security alarm systems to running airplanes and nuclear power plants. As impressive as the advances in computing discipline are, there are different views on what exactly is computer science. Is it a science? Or, is it an engineering discipline? Or yet, is it an art? All of these view points seem equally valid given one’s exposure and experience of the discipline. It is a science because of its rigorous mathematical underpinnings and its core is rooted in computability theory, formal languages, and algorithmics, among others. It is an engineering discipline in that precise engineering design and micro-manufacturing processes go into the making of the computers. Those that had the fortune of building and maintaining complex, enterprise-scale applications will attest to the fact that software development is by far carried out as an art form practice rather than as an engineering practice. Before we embark on our study of computer science, in light of the above observations, it is imperative that we answer the question of precisely what body of knowledge constitutes the computer science discipline. We expect the answers to this question identify the core concepts and practices in computer science. It would be an added bonus if the answers also include the types of problems that computers have been used to solve and how the solutions have been developed. Therefore, objectives for this chapter are to: Provide a conceptual description of subjects areas of computer science that are collectively regarded as representing the core principles and practices in the discipline. Describe various classes of computers and their intended use. Explain types of system software and their functions. Explain embedded software and its applications. Discuss various application software and the problems that they solve. Provide an overview programming language concepts and describe programming paradigms. Introduce the concept of abstract machine hierarchy. 1.1 Facets Of Computer Science There seems to be no consensus on precisely what body of knowledge constitutes the discipline of computer science. Even if such an agreement were to exist, it is subject to change due to technological innovations and the range of problems that have been solved using a computer. The Joint Task Force on Computing Curricula 2001 has identified the following areas: Discrete Structures, Programming Fundamentals, Algorithms and Complexity, Architecture and Organization, Operating Systems, Net-Centric Computing, Programming Languages, Human-Computer Interaction, Graphics and Visual Computing, Intelligent Systems, Information Engineering 1, Software Engineering, Computational Science and Numerical Methods, and Social and Professional Issues. In the following subsections, each of the subject areas is described in some detail. It should be noted that the subject area boundaries are rather fluid and tend to change with time and technological advances. 1.1.1 Discrete Structures Discrete Structures is to Computer Science what Calculus is to all the engineering disciplines. No engineering student can expect to master the discipline without a thorough knowledge of Calculus. In a similar vein, the study of Discrete Structures is fundamental to the study of Computer Science. Discrete Structures is the study of mathematical problems concerning finite or discrete sets. It provides many different mathematical models that have direct relevance to the problems encountered in Computer Science and Operations Research. These mathematical models can be described using finite sets and their structures. In contrast with Calculus, where the phenomenon of interest is continuous — air flow around the wings of an aircraft, pressure distribution across the thickness of a water pipe — Discrete Structures focuses on modelling and analyzing the phenomenon that is intrinsically discrete in nature. Discrete Structures encompasses the study of Sets, Relations, Functions, Mathematical Logic, Combinatorics, Discrete Probability, Digital Logic and Digital Systems, and Algebraic Structures. Other topics such as Formal Languages, Algorithm Analysis and Computational Complexity, Graph Theory, and Trees are also within the realm of Discrete Structures. The latter body of knowledge is often considered as application of Discrete Structures to Computer Science. The concept of a set, set operations and structures — union, intersection, difference, complement, subsets, sequences, partitions, relations between sets, functions that map elements from one set to another — are fundamental topics in Discrete Structures. Relations between elements of sets is the foundational basis for relational data model. The industry standard language for querying relational databases—SQL (Structured Query Language)— is based on set theory. The rules of logic are used in writing computer programs, in designing computer chips, and in the construction of mathematical proofs. Mathematical induction is another proof technique that is widely used in Computer Science. It can be used, among other things, to show that a program with loops performs as expected. Combinatorial techniques are used in enumerating all possible solutions to a problem and has direct application to optimizing queries in relational databases. Using a mathematical theory of probability, one can compute the likelihood of complex events occuring under the assumption that the events are governed by appropriate axioms. Discrete probability is computed by summing (instead of integrating as in the case of continuous probability) the probabilities of individual events comprising a complex event. A sequence is an ordered list of objects drawn from a set. A binary sequence is a sequence whose elements are drawn from the set {0,1}. All data and programs are encoded as binary sequences for execution on a computer. Binary arithmetic is used to manipulate data and programs by a computer and is the basis for digital logic and digital systems. Computational complexity theory is an area of theoretical computer science concerning what problems can be solved by any computer. On the other hand, algorithms study is concerned with devising efficient and effective algorithms for solving a given problem. 1.1.2 Programming Fundamentals This area of Computer Science is concerned with developing computer programs. It encompasses the study problem solving techniques; algorithm design and analysis; structures for representing data; control structures as elementary building blocks in program construction and as a means to effect flow of control in program execution; debugging and testing strategies to insure correctness of programs, abstraction mechanisms for constructing programs; and abstraction and encapsulation mechanisms for packaging programs into functional components. It is also concerned with programming paradigms — a set of well defined and proven high-level algorithmic steps useful in naturally solving a class of problems that exhibit certain common characteristics — and the programming languages that support the paradigms. Imperative, object-oriented, event-driven, and functional are different programming paradigms. Program translation from a high-level language to a language that computers understand is also within this realm. 1.1.3 Algorithm and Complexity Solving problems has been the hallmark of human endeavor since times immemorial. Typically a problem has input. For example, if the problem is ``Find directions to drive from Dayton, OH to Detroit, MI,&quot; the inputs are Dayton, OH and Detroit, MI. A solution to this problem is precisely specified directions to drive from Dayton to Detroit. Solution is also referred to as the output. An algorithm describes the process of turning inputs into output. It is a precise specification of the process. The specification is in terms of a series of steps. Each step contributes to the solution. The steps should embody computation that is feasible. The algorithm should contain a finite number of steps so that the algorithm is guaranteed to terminate. We would like the algorithm to be efficient — get the work done in the least amount of time possible. We would also like the algorithm to consume as minimal amount of resources as possible. If an algorithm is executed by a computer, the resources are memory and processor cycles. Finally, we want the algorithm to be generic — should be able to find driving directions between any two pairs of cities and not just between Dayton and Detroit. An algorithm can be executed by a human, a robot, or a computer. Algorithms and Complexity area of Computer Science is concerned with identifying what types of problems are amenable for algorithmic solutions, and devising suitable algorithms that are both effective and efficient. 1.1.4 Computer Architecture and Organization A computer is a complex system comprising of multiple subsystems — processor, memory, input/output devices, sensors. Each subsystem in turn can be composed of several other components. A communication mechanism is also needed to enable these subsystems to cooperatively execute tasks. Computer architecture refers to the design principles employed in selecting and configuring the various components to produce a computer with the desired functional and performance characteristics. An architecture is open if its design principles are based on a framework that is not rigid and conforms to industry standards. Open architectures enable building computers by mixing and matching off-the-shelf components from different vendors. A closed architecture system is one that is based on a proprietary design and cannot easily connect to other vendor components or systems. Differences in the architecture, functional capabilities and performance characteristics of the subsystems entail in classes of computers — tablet computers, laptops, desktops, workstations, servers, mainframes, and supercomputers. Each class is intended for solving a set of problems or for use by a segment of the computer user population. Computers, in general, have the following components: Central Processing Unit (CPU), memory, input/output (I/O) devices, and a bus to interconnect these components (See Figure (fig:LANDetail). This area is also concerned with the programmability aspects of the computer at the machine level. Firmware is a collection of programs that control the components within a subsystem. Firmware is used to control and coordinate the processor components to effect the execution of programs written in the machine language. Firmware programs are permanently stored in Read Only Memory (ROM) since they don’t change over time. 1.1.4.1 Central Processing unit (CPU) CPU is composed of Arithmetic and Logic Unit (ALU), and Control Unit (CU). As the name implies, ALU performs basic arithmetic operations (addition, subtraction), moving data from one location (register) to another, and logical operations such as AND, OR, and NOT on binary strings. ALU can also perform relational operations (\\(=, &lt;&gt;, &lt;, \\leq, &lt;, \\geq\\)) on numbers and strings. A CPU is designed to execute a pre-defined repertoire of machine instructions, referred to as its instruction set. A machine language program is a sequence of machine instructions assembled to solve a problem. CPU is capable of understanding and executing its machine language programs. Advances in microelectronics have led to creation of the entire CPU on one or a small number of integrated circuits; computers with such CPUs are known as microprocessors. Computational speed of a CPU is designated in terms of clock rate or cycles per unit time. Some machine instructions are executed in one CPU cycle time, while other may require multiple CPU cycles. The clock rate of a computer is normally determined by the frequency of a crystal. The original IBM personal computer had a clock rate of 4.77 MHz (close to five million cycles/second). Some recent Intel’s Pentium chips run at 2.4 GHz (close to 2.5 billion cycles/second). The clock rate of a computer is only useful for providing comparisons between computer chips in the same processor family. Clock rate should not be used when comparing different computers since the amount of work different computer chips can do in one cycle varies. In addition to clock rate, there are many other factors to consider when comparing different computers. 1.1.4.2 Memory Memory is used to store computer programs and as a scratch pad for storing the intermediate results of a computation. Random Access Memory (RAM) is a type of memory, which is fast and expensive relative to other types. The term random access means that access to any piece of information in RAM takes the same amount of time. RAM is volatile — when the power is off the data disappears. RAM is referred to as primary memory or primary storage device. Other types of memory medium or devices include registers, cache, magnetic disks, magnetic tapes, optical disks, and CD-ROM (see Figure . 1.1.4.3 Input/Output (I/o) Devices I/O devices are used to bring data into the computer and move the data out of the computer. Common I/O devices include the ubiquitous keyboard, monitor (or computer screen), mouse, (hard or magnetic) disk drive, tape drive, CD-ROM (Compact Disk - Read Only Memory), CD-RW (Compact Disk - Read Write), scanner, and printer. Others include Network Interface Card (NIC), optical disks, video and audio capture devices, and sensors of various kinds. Unlike RAM, data stored in magnetic disks and CD-ROM is non-volatile. Information can be erased and rewritten to magnetic disk over and over. Such I/O devices are known as read-write. CD-ROM, on the other hand, allows writing information only once but it can be read any number times. Such devices are referred to as WORM (Write Once Read Many). CD-RW is like a magnetic disk — data can be erased and rewritten. However, CD-RW is smaller in storage capacity and takes longer to access the data. Since access to data on disks takes relatively longer time compared to RAM memory, they are referred to as secondary storage devices. Optical disk is another type of storage device for storing large amounts of data. Since optical disk and tape device access times are even greater than that of magnetic disks, they are referred to as tertiary storage devices. Because large amounts of information can be stored on disks and CD-ROM, they are also known as mass storage devices. It should be noted that magnetic disks, optical disks, and CD-ROMs are random access devices, whereas tape drive is a sequential-access device. Information can be read from a sequential-access device in the sequential order — to read data item \\(n,\\) the first \\(n-1\\) data items need to be skipped over. The distinction between random-access and sequential-access devices is akin to that between an audio CD and audio tape. 1.1.4.4 Bus Bus is an integral part of any computer and is used to transmit data, address, and control information among the components. There are busses within the CPU. Buses are also needed to connect the CPU to external memory and peripheral devices. Depending on the type of data they transmit, they are referred to as data bus, address bus, and control bus (see Figures ?? and ??. Despite their names, they are really a single bus since any one is useless without the others. Width of a bus is its structural characteristic and designates number of parallel connectors. The wider the bus, the more information it can transmit. Both the bus width and its clock rate determine its data rate — the number of bytes it can transmit per second. Most current microprocessors have 32-bit busses with a clock rate of 100 or 133 megahertz (MHz). The bus clock is typically slower than the CPU clock. Various bus designs have been used in personal computers, including ISA, EISA, Micro Channel, VL-bus and PCI. 1.1.5 Operating Systems An Operating System is a program that interfaces between the user and the computer, application programs and the computer. It is the most important program and is entrusted with great many responsibilities. Every general-purpose computer comes with an operating system. Windows XP and UNIX 2 are two operating systems that are widely used. 1.1.5.1 Characteristics Operating systems are characterized by attributes such as multi-user, multi-processing, multi-tasking, and multi-threading. A multi-user operating system permits several users to use the computer concurrently and each user is allowed to execute several programs concurrently. A multiprocessing operating system enables running a program using multiple processor on the same computer. Multitasking endows an operating system with the capability to run multiple programs concurrently. Multitasking capability is a prerequisite for multi-user operating systems. Multithreading characteristic allows running different parts of a single program to run concurrently, possibly on different processors. A real-time operating system is one that has a predictive behavior — responds within a specified interval of time. They are are used in embedded systems for managing, for example, nuclear power plants. 1.1.5.2 Functions An operating system performs multiple functions in different roles — security manager, process manager, command interpreter, resource manager, scheduler, file system manager, among others. As a security manager, it is responsible for insuring that only authorized users can access the system and execute only those functions that they are entitled to. A program in action is called a process. A program needs resources such as the processor and memory to become a process. As a process manager, the operating system is responsible for assigning the required resources to the processes, starting and terminating them, insuring that processes execute without interfering with each other and share common resources in a mutually exclusive manner when needed. Users and programs interact with the operating system through a set of commands and system calls. For example, commands exist for copying, renaming, and deleting a file. The part of the operating system that intercepts and processes these commands is called a command processor, command line interpretor, or shell. IN resource manager’s role, it a responsible for managing the system resources (processors, memory) and the peripheral devices (e.g., disk systems, printers, keyboard, mouse) and providing access to them for users and programs via application programming interfaces. The operating system also takes on the responsibility of scheduling requests for processors, disks, and printers. As a file system manager, it is responsible for allocating space for user and application files, organizing and keeping track of files. Most of the operating systems feature a hierarchical file system in which files are grouped into directories and directories form an inverted tree structure. Another important function of an operating system is to provide mechanisms for processes to communicate with each other — InterProcess Communication (IPC). Techniques such as shared memory and messaging are used for IPC. An operating system usually provides a set of utility programs. These utilities vary from simple text editor, to text formatters, to compilers and sophisticated program debugging tools. Especially the UNIX operating system comes with a powerful set of utility programs. The latter can be strung together using a scripting language to accomplish significant tasks without writing any programs at all. 1.1.6 Net-Centric Computing No matter how powerful a computer is, by itself its use is rather limited. The real power of computing comes into play when two or more computers can communicate and collaboratively solve complex problems. A group of computers that are connected via a communication mechanism is referred to as a computer network. Each computer in a network is called a node. There are different types of networks including local area networks (LANs), wide-area networks (WANs), campus-area networks (CANs), metropolitan-area networks (MANs), and home-area networks (HANs). 1.1.6.1 LANs omputers on a LAN are geographically close together, more often reside in the same building. Each node on a LAN has its own CPU with which it executes programs. A node can also access other nodes on the LAN. This enables sharing expensive resources such as plotters and color printers among the LAN users. Similarly, files can also be shared. LAN users can communicate with each other via e-mails and instant messengers. There are many different types of LANs. Best known among them are Ethernets for desktop computers and workstations, and AppleTalk for Macintosh computers. LANs are differentiated based on topology, protocols, architecture, and media. Topology refers to geometric arrangement of nodes in the network. There are different topologies — ring, bus, star, point-to-point. Bus topology LAN is shown in Figure 1.1. Protocols are the rules for communication between the nodes including the type of error checking to be used, data compression method, how the sending device will indicate that it has finished sending a message, and how the receiving device will indicate that it has received the message. LAN architecture refers to how the nodes collaborate in accomplishing a task: peer-to-peer and client-server are two such architectures. Media refers to either physical (e.g., twisted-pair wire) or non-physical (e.g., radio waves for wireless networks) medium that is used to connect the nodes. Other physical media choices include coaxial and fiber optic cables. Figure 1.1: Bus Topology LAN One LAN can be connected to another LAN over any distance using a suitable media. A system of LANs connected in this way is referred to as a WAN. Internet is a best example of a WAN in existence. Thus, Internet is a mammoth network of networks and connects millions of computers globally. Any computer connected to the Internet can communicate and exchange data with any other computer on the Internet subject to security constraints. 1.1.6.2 CANs, MANs, and HANs Nodes in a CAN are limited to a geographic area, such as a military base, an industrial area, or a campus. MANs are networks designed for a city or town. HANs refers to a network contained within a user’s home that connects home computers, DVD players, home security systems, and ``smart&quot; appliances. Like any other engineering task, network design involves careful tradeoff between various facets — topology, protocols, architecture, and media. For example, in case of protocols, some are simpler than others, some are faster, while other are more reliable. 1.1.6.3 Application Architectures A computer network unfolds several distributed architectures for developing applications — Client-server, Multi-tier, Web-based, Services-based. Client-server is an application architecture where a specific computer is designated as the server which provides a specialized service centrally. Print servers, file servers, and database servers are examples of this category. Clients are other programs or computers which request services of the server. Typically the server and the clients are connected using a LAN and the computers themselves can be of disparate types. Client-server architecture is an example of two-tier (application) architecture. The server constitute one tier and the clients constitute the other tier.Multi-tier architecture is a generalization of two-tier client-server architecture. A node can act as a server under one context and as a client in another context. In a service provider role the node acts as a server, and in service requestor role it acts as the client. The nodes in a multi-tier architecture are typically confined to a LAN or WAN. Web-based architecture takes the multi-tier architecture to the next level by removing the requirement that the nodes be confined to a LAN or WAN. Any node on the World-Wide Web (WWW, or simply Web) can be a service provider or service requester, or both. It should be noted that Internet and WWW are not synonymous. Web is a way of accessing documents on the Internet using HTTP (HyperText Transport Protocol). Such documents are formatted using a markup language called HTML (HyperText Markup Language). The Web also enables accessing other types of documents including animations, audio and video clips, and graphics. Not all the Internet servers participate in the WWW. Internet is also used for transmitting e-mail using SMTP (Simple Mail Transport Protocol), Usenet news groups, FTP (File Transfer Protocol), and instant messaging. Every computer that communicates over the Internet is assigned an IP address. This address uniquely identifies the computer and distinguishes it from other computers on the Internet. An IP address is 32 bits in length. Web servers are specialized computers that process requests for information sent over the Web using the HTTP protocol. Microsoft Internet Information Server (IIS), and Free Software Foundation’s Apache are well-known Web servers. Web browsers are programs that are used to navigate the Web and to render the HTML documents. Netscape Navigator and Microsoft Internet Explorer are two popular Web browsers. 1.1.6.4 Security Security is one of the greatest challenges in this area and is critical to electronic commerce (e-commerce) applications. It is of two fold. The first one is authenticating the identity and determining the entitlements of the requester. The second one is to insure that the data is transmitted in an encrypted form and unauthorized users don’t siphon off the data using sniffers. Effective tools and techniques for network management — monitoring the network for node failures, network congestion, sabotage, and attacks — are equally important. SNMP (Simple Network Monitoring Protocol) is a protocol for this purpose. Recent advances in multimedia technologies coupled with Web-based architecture contributed to the emergence of new applications for distance learning, distributed collaborative problem solving, and net meetings. 1.1.6.5 Web Services The most recent distributed computing architecture aims at programming the Web. Under this scenario, a software application is ``weaved&quot; by composing services from different servers on the Web. For instance, a word processor application is composed by making use of three service providers — one provides a text editor, the other provides a formatting engine, and yet another provides a spell checker. Industry converging on standards like SOAP (Simple Object Access Protocol), UDDI (Universal Description, Discovery, Integration), XML (eXtensible Markup Language), and WSDL (Web Services Description Language) is helping to propel services-based distributed computing towards a reality. 1.1.7 Programming Languages This realm of Computer Science is concerned with designing programming languages for encoding algorithmic solutions so that the latter can be executed by a computer. Solving a problem using a computer is a two step process. First, a suitable algorithm need to be devised. Second, the algorithm is expressed in a language that the computer understands. Such languages are called programming languages. Natural languages — for example, English — are too complex for a computer to comprehend. Furthermore, algorithm steps expressed using a natural language may lack precision and thus entail ambiguity. A programming language, on the other hand, has a unique set of keywords that it understands, a well-defined syntax and semantics, and control structures. Syntax refers to the grammatical rules of the language governing the construction and organization of program statements. Semantics refers to the meaning of various statements in the language from the computation point of view. Control structures direct the order of execution of statements in a program. Languages such as COBOL, FORTRAN, Visual Basic, C++, Java, and C# are referred to as high-level programming languages. Their syntax and programming constructs available for organizing program instructions are at a higher level of abstraction. Programs can also be written using a machine language. Such programs are amenable for direct execution on the computer. However, machine languages feature a lower level of abstraction and a machine language program is simply a string composed of binary digits 0 and 1. Programs written in high-level languages are translated into machine language by a program called the compiler. Languages that fall between machine languages and high-level languages are called assembly languages. Though assembly languages are similar to machine languages, they are relatively easier to program since they allow substituting symbolic names for binary numbers. An assembler is a program which translates assembly language programs into machine language. Even today some programs are developed in assembly language since the latter offers direct access to a computer’s memory structures and results in efficient programs in terms of execution speed. There is a class of languages above the high-level languages called the fourth-generation languages. They are typically intended for use by non-programmers. Users declaratively specify what needs to be accomplished as opposed to how it can be accomplished. There exists a multitude of programming languages. Which language is appropriate for a given task depends on various factors. Every language has its strengths and weaknesses and is designed for use in solving a specific class of problems.Section 1.6 1.1.8 Human-Computer Interaction Human-Computer Interaction (HCI) is a discipline concerned with the study, design, construction, and implementation of human-centric interactive computer systems. HCI’s scope is more than just designing and implementing Graphical User Interfaces (GUIs) and menus that are intuitive and easy to use. It is a very broad discipline and draws upon ideas and advances in sociology and anthropology, psychology, linguistics, and ergonomics. Sociology and anthropology address the issues that arise out of interactions between work and organization, and technology. It is also concerned with the way human systems and technological systems adapt to each other. Psychology comes into play to make the user interaction more intuitive by modelling human cognitive processes and the behavior of the users. Linguistics role is in the development of natural and machine languages and the interplay between the two. Ergonomics is the study of physical design of workspace, lighting, chair, keyboard, physical screens or monitors, and related peripheral devices, and the manner in which people work and interact in such a space or environment. Ergonomic design is vital to insure the safety of computer users from problems such as repetitive stress syndrome. Early computer systems provided a simple character-based interfaces using a keyboard. Then GUIs and menus became popular user interfaces and mouse was the preferred device to navigate these interfaces. Graphics and image processing systems employed a device known as graphics tablet to effect direct interaction with a graphic or image, whereas game systems employed joy stick as the device for interacting with the game programs. Point of Sale (POS) systems, Personal Digital Assistants (PDAs), Kiosks, Automated Teller Machines (ATMs) employ a combination a simplified keyboard, pen or stylus, and touch panels as means for providing the user interfaces. The advent of the Web and advances in multimedia technology brought additional challenges to the HCI. Interfaces for Web applications should be designed as interfaces for the masses — intuitive and easy to use, require little or no training, minimize the likelihood for making mistakes, recover gracefully from user interaction mistakes. Interacting with multimedia data — text, images, graphics, audio, video, animation — demands innovative interfaces that are intrinsically suited to the type of media. For example, images can be queried based on color, texture, type of objects contained in the image, object’s shape, spatial layout of the objects, and a combination of these. To query images based on some of these characteristics, an user interface that allows the user to sketch a query — query by example — maybe a logical choice. As computers become more entrenched in our society, HCI assumes even a greater role in looking for ways and means to making the interaction with the computer systems more intuitive, efficient, and safe. 1.1.9 Graphics and Visual Computing This facet of Computer Science deals with generation, capture, processing, manipulation, display, and printing of visual information. There are three subareas: Computer Graphics, Images and Video, and Visualization. There are two major aspects to the study of these subareas — physical devices that are used for generating, capturing, and displaying/printing of visual information, and the software programs that are used to process and manipulate the visual information for various purposes. 1.1.9.1 Computer Graphics Computer Graphics is concerned with generating synthetic images and rendering them to look realistic. There are four broad categories of graphics software: Paint programs, Presentation graphics, Illustration graphics, and Design graphics. Paint programs are low-end graphics programs that are used to create freehand drawings. The drawings are stored in a raster-based format such as bitmap and can easily be edited. Microsoft Paint is an example of this category. Presentation graphics are programs that are used to create graphics that are typically used in slide shows and reports — bar charts, pie charts, line graphs, scatter plots. The data for these graphics can be imported from spreadsheet applications such Lotus 123 or Microsoft Excel. Spreadsheet programs themselves have capabilities for producing most commonly used charts and graphs. Illustration graphics software sports more advanced features that are often required in engineering drawing and graphic arts. Adobe Illustrator and CorelDraw are well-known programs in this category. Design graphics software is the most advanced and sophisticated among the graphics programs. It is primarily used by engineers for designing automobiles, aircraft, ships, computer chips, and various sorts of machine parts. Design graphics software is known as CAD (Computer Aided Design) software. 1.1.9.2 Images and Video In contrast with the computer graphics, images and video subarea focuses on capturing images of an existing artifact and processing them for various purposes. Processing is done for improving the visual appearance of an image (e.g., photo touch up using programs such as Adobe Photoshop), restoring a degraded image to its original form (typical of remotely sensed satellite imagery),and extracting features and measuring them (as done in medical imaging to aid in disease diagnosis). 1.1.9.3 Visualization Visualization involves the study of techniques for revealing meaning hidden in the data. It offers techniques for exploring, analyzing, and communicating information about the data. Scientific visualization refers to communication of knowledge via visualization techniques. Animation is related to visualization, and involves showing several graphics or images in quick succession to simulate motion. Animation techniques are widely used in applications such as flight simulators, arcade games, and movies. 1.1.9.4 Common Issues The following issues transcend all the three subareas. Graphics and image data tends to be voluminous and processing is memory- and processor-intensive. Typically images and graphics are transmitted in compressed format for efficiency reasons. Applications that support graphics and images require powerful workstations or specially designed graphics workstations. The pervasiveness of graphics and images has resulted in large graphics and image repositories. This has necessitated the need for powerful yet flexible retrieval techniques to identify and retrieve relevant images from the repositories. 1.1.10 Intelligent Systems This branch of Computer Science is concerned with various aspects of developing computer systems that exhibit human-like intelligent behavior. Cognitive tasks performed by humans are of two kinds — commonsense tasks and expert tasks. Commonsense tasks are the ones such as conversing in a natural language, and walking. Expert tasks, on the other hand, require a great deal of domain expertise. Writing a technical paper, diagnosing diseases, and performing surgery are examples of expert tasks. Initial investigations in this area were on game playing, natural language translation and understanding. Impressive advances were made recently in game playing. A chess program running on an IBM supercomputer defeated world chess champion Gary Kasparov in a match in 1997. Natural language processing offers the greatest potential rewards especially in the area of human-computer interaction. However, the problem remains elusive to date. Machine learning, visual perception and image understanding, robotics, and knowledge-based expert systems also subsequently came under the realm of intelligent systems. Machine learning aims at designing strategies and techniques for computer programs to learn from examples and experiences. Neural Networks are learning systems that simulate human intelligence by attempting to reproduce the types of physical connections that occur in biological brains. They made significant inroads in a number of disciplines such as voice recognition, pattern recognition and classification.Visual perception and image understanding deals with endowing computer systems (e.g., robots) with human-like vision capabilities so that they can navigate the physical space which is possibly hazardous for humans — nuclear power plants, areas infested with biological weapons — understand the scene, and perform useful actions. The present state of the art in robotics is limited to using them in a highly controlled environments for repetitive tasks — configuring and packaging products in factory assembly lines. Knowledge-based systems or knowledge-based expert systems is an umbrella term to refer to a class of programs which configure and perform according to the domain knowledge made available to them. 1.1.10.1 Knowledge Representation and Inference Central to the domain of intelligent systems are the concepts of knowledge representation and inference. Domain knowledge is one of the prerequisites for intelligent behavior. Therefore, a principal task in building intelligent systems is encoding or representing the domain knowledge into suitable data structures. Inference rules encode the reasoning methods — deriving new knowledge from the existing knowledge — associated with the knowledge representation schemes. If representational details are omitted, there are three main approaches for knowledge representation: slot-and-filler structures, logical formulas, and production rules. Under slot-and-filler structures method, the domain of discourse has certain domain objects. Slots are attributes which are used to describe the properties of domain objects. Fillers are the values assigned to these attributes for a specific instance of the domain object. The domain objects are cast in a hierarchical tree-like structure to capture the relationships among the objects. Inference is effected by matching the values that represent the task context with relevant part of the tree structure and traversing the tree up and down based on the domain object relationships. In the second approach, logical formulas are used to describe the domain objects and to capture the relationships among them. The formal power of logical theorem proving is used to infer new knowledge. However, this may result in combinatorial explosion — number of choices to choose from at each step of a solution is large and all choices need to be systematically explored to arrive at a solution — renders the method impractical. In the last approach, domain knowledge is represented as production rules. Production rules are of the form: IF condition(s) THEN action(s). For example, in the domain of disease diagnostics, conditions represent various symptoms and the action part specifies what the disease might be. The action part may include a weight (in the range 0 to 1), known as certainty factor, to indicate the degree of faith in the recommended action. 1.1.10.2 State Space Search A prerequisite for solving problems is that they must be precisely defined. State space search paradigm is a powerful, general-purpose framework for rigorously defining the problems. Problem definition, under this framework, encompasses five steps: defining state space, the initial state(s), the final or goal state(s), rules that govern transitions between the states, and heuristic knowledge such as preferred or recommended transitions between the states under different contexts. Then, a solution to the problem is finding a path through the state space beginning at an initial state and ending at an end state. As an example, for board games such as chess, state space is the chess board configuration. Initial state is how the pieces (i.e., soldiers, knights, pawn, queen, king) of the two players are positioned on the board at the beginning of the game. Goal state(s) are the positions in which opponent’s king has been captured. Rules are the legal moves of the chess game, and the heuristic knowledge are the functions that evaluate board positions to assess their chance that they will lead to a win, standard opening moves, etc. Though there exists several programming languages for constructing intelligent systems, LISP and Prolog are the well-known ones. 1.1.11 Information Engineering Information Engineering addresses issues related to structuring, storing, and retrieval of structured, unstructured, and semi-structured data. It is also concerned with transforming data into information. Volume of data considered here can be in the order of terabytes (A terabyte is \\(2^{40} = 1,099,511,627,776\\) bytes.).Structured information has well-defined structure and semantics. For example, a collection of employee records is a piece of structured information. An employee record may consist of first name, last name, address, date of birth, title, and salary. Collection of such records can be stored in a file or a database table and retrieved based on various criteria such as: names of employees whose salary exceeds $50,000. It is assumed that the attributes first name, last name, address, date of birth, title, and salary capture all the information of interest about an employee. Using data modelling techniques, one can determine information entities or elements, their attributes, constraints on the entities, relationships between the entities to meet the information needs of an organization. The resulting artifact is referred to as a data model. In other words, data model is an abstraction for describing the information elements, their semantics and constraints, and the relationships among the elements. 1.1.11.1 Structured Information Initially file systems were used for managing the structured information. File system have several shortcomings. Database Management Systems (DBMS) were introduced to remedy these shortcomings and to deal with massive amounts of data. DBMS provides a secure, shared, and concurrent access to the data, eliminates data redundancy (i.e., avoids storing multiple copies of the same data) and the concomitant inconsistency problem, enforces integrity constraints on the data (e.g., an employee’s salary can never be a negative number), provides transactional capability (ability to treat several database operations as one logical operation at the application level), and automatically recovers from software and hardware failures. An overarching design objective for a DBMS is to provide data independence –— the ability to change the database structures without changing the applications that use the database. 1.1.11.2 Unstructured Information Unstructured information, on the other hand, has no well-defined structure and semantics. For example, consider a collection of technical research papers. How do we model the information content of a paper? What portion of the document do we consider for the modelling task? Do we consider only the title, authors, title and abstract, or the entire text of the paper? A set of keywords? Or, a set of keywords with weights that are proportional to their relative significance in reflecting the information content of the paper? How are user queries specified? What matching strategies are used in identifying relevant documents to the user query? Solutions to these issues become even more difficult if we extend the unstructured information to encompass multimedia data—graphics, images, animation, audio and video. Information Retrieval systems are used for managing textual document collections. Multimedia data is managed using Multimedia Retrieval Systems. 1.1.11.3 Semi-Structured Information In between the structured and unstructured information lies semi-structured information. Examples of this kind include markup documents such as HTML and XML. The structure and semantics of semi-structured documents is not as rigid and precise as in the case of structured information. Semi-structured information is managed within the framework of relational, object-relational, or object-oriented database management systems with suitable extensions. One aspect of Information Engineering that transcends both semi-structured and unstructured information is how it is presented or displayed, better known as multimedia presentation. The goal of Hypertext and Hypermedia Systems is to address this problem. These systems have important practical uses in searching on-line documentation, digital libraries, and computer-based training (CBT). 1.1.12 Software Engineering Software Engineering (SE) is concerned with developing reliable and safe software-intensive systems. It addresses not only the technical aspects of building software systems, but also project management issues, such as organizing and directing programming teams, forecasting resources, scheduling, and budgeting. Life cycle of a software project encompasses the following steps: requirements gathering and analysis, requirements specification, conceptual and detailed design, construction, testing, deployment, and maintenance. Software Engineering employs rigorous and systematic engineering approaches to developing software systems that meet the specified functional and non-functional (e.g., performance, availability, reliability) requirements. It provides processes and methodologies, and measurement techniques to insure quality and to track progress. 1.1.12.1 Requirements As simple as it may seem, gathering requirements is one of the difficult task. It is hard even for those who are intimately familiar with the problem domain to articulate the requirements in a level of detail to generate a requirements specification document Use cases and use case stories are two techniques that have come into existence recently to help with the requirements elicitation task. Rapid prototyping is another technique for eliciting requirements. This requires quickly building a (throw-away) prototype and using it as a means to probe the system users to discover the requirements. Joint Application Development (JAD) is a methodology that requires the involvement of both the system users and system developers in defining the system requirements. If the proposed system is a replacement for an existing (legacy) system, it is important to carefully glean the requirements realized in the existing system. This is a good starting point to which additional requirements can be added to. Several systems have failed due to what is known as feature regression — the new system upon completion didn’t even have those features of the existing system, let alone having new features. There is an interesting corollary to this. Several software projects have failed due to the inability in precisely defining the scope and functionality of the system. This is referred to as scope and feature creep. 1.1.12.2 Design Software design is the process of precisely specifying how the system is going to be built, given the requirements specifications. There are several software design methodologies including Structured Analysis and Design, Object-oriented Analysis and Design (OOAD), and Component-based Design. Software design has several goals including reuse, maintainability, and reliability. Unified Modeling Language (UML) — a set of formal and informal notations — is an industry standard language for documenting various artifacts of software design. Based on years of collective software engineering practice across various problem domains, a set of best practices have been captured and documented — design patterns. A design pattern is simply a problem-solution pair. It describes the characteristics of a generic problem and demonstrates a proven solution. The idea is that if the problem at hand is similar to the problem that a design pattern solves, then simply use the solution recommended by the design pattern rather than reinventing the wheel. 1.1.12.3 Construction Construction is converting the design into code. It may also require reusing code developed for another project or code purchased in the form of code libraries or class libraries. Code libraries feature an API (Application Programming Interface). API specifies the syntax and semantics for using the functionality manifested in the code library in the form of library calls. A code library typically will have hundreds of functions and procedures and there is an API associated with each function and procedure. Class libraries feature functionality at a class level. A class has both structure and behavior. Behavior of a class is made available via methods of the class. Making use of functionality of a class involves either invoking the methods of the class or developing a new class based on the classes in the class library. 1.1.12.4 Validation Testing is one aspect of software validation. The goal of testing is to uncover any errors or bugs in the software before it is put into production. There are two approaches to testing: black-box and white-box. Under the black-box approach, testing is carried out without knowing how a piece of software has been implemented. Focus is on whether or not the software is producing the expected results for a given set of input values. In contrast, white-box testing looks into the implementation details of how a piece of code has been implemented. There are several types of testing: unit, integration, system, user acceptance, and regression. Unit testing focuses on a small piece of code, usually a procedure, function, or a class. Unit testing is the only test type done by the developer of the code. All other test types are typically carried out by a separate Quality Assurance (QA) team. In integration testing, several unit-tested pieces of software is tested together to validate their collective behavior.System testing is done in an environment which is quite similar or identical to the environment in which the system will go into production. The intent here is to validate the interaction of the system under development with other subsystems, and to insure compatibility with the infrastructure and other environmental factors of the production environment. Other validation techniques include design reviews, and code inspections. There are formal methods to validate software systems. However, they are not practical even for small, realistic systems. 1.1.12.5 Deployment Activities in the deployment phase include installing and configuring the system in the production environment, insuring that the production environment features the required infrastructure and meets other environmental requirements, migrating the data from existing or legacy system into the new system, and providing training to the people who will be managing and using the new system. 1.1.12.6 Maintenance Maintenance phase activities comprise fixing bugs (i.e., software errors) as discovered by the users, and making patch releases to replace a portion of the code that has been changed to fix the bugs. Maintenance may also include software evolution —– feature enhancements to the system as requested by the users. 1.1.12.7 Availability and Reliability Availability is the probability that the system is available for users at any given time. It is concerned with making a software system fail-safe. This involves identifying all single points of failure in the system and providing redundancy and fault-tolerance based on a chosen software availability model. Reliability, on the other hand, is the probability that the system is producing the correct results. Like most other engineering problems, there is a trade-off between the degree of availability and reliability desired and the costs in providing them. 1.1.12.8 Project Management Not all software project management issues are unique to software projects. In fact, most of the issues apply equally to other types of projects such a construction of a high-rise building. Activities include putting the project team in place, defining their roles and reporting responsibilities, determining training needs, and documenting protocols for team communication. A detailed project plan showing task level breakdown of the project activities, resource assignment, task duration, and task dependencies needs to be produced as well. This is a living document in that it should always be current and valid. Proper tools are needed for tracking project progress, software versioning and configuration management, software validation, and issues and bugs tracking. Assessing and managing risk as well as fall-back options are also necessary tasks in the project management. 1.1.12.9 Reuse Writing code from scratch is not the only way to develop software systems. Reusable pieces of code in the form of code libraries and class libraries has been used to reduce the development cycle time. However, this type of reusability is at the code level. What is needed is the reusability at a functional level. In case of the banking domain, application-level functionality is such as creating an account, transferring funds from one account to another, producing a period-end statement, and inquiring account balance. True reusability is achieved when such application-level functionality is packaged into components which can run on any computer, and are accessible from any other computer over the network. This is the domain of component-based software. Under this scenario, it possible to develop an application quickly by assembling and configuring the relevant software components. Web Services is an industry initiative in this direction. However, it should be recognized that there are inherent risks in this approach. 1.1.13 Computational Science and Numerical Methods This is an area that encompasses topics in numerical analysis, operations research, modelling and simulation, and high-performance computing. They are of greater interest to engineers and physicists. Applications include simulations, scientific visualization, economic forecasting, weather forecasting, structural analysis using finite element methods, fluid dynamics, molecular modelling, computational biology, bioinformatics, and geological modelling to name a few. They are characterized by massive computations and the required computing power is only available in a specially designed high-performance computers. Numerical analysis is concerned with floating-point arithmetic, error control, stability, convergence of series, numerical integration and differentiation, differential equations, linear algebra, iterative solutions for finding roots of polynomials, and curve fitting. Operations research investigates issues in linear programming, probabilistic modelling, network analysis and routing, prediction and estimation, and dynamic programming. Modelling and simulation has many practical applications. It is used to study system behavior without actually constructing the system. Constructing a real system may be cost prohibitive or unsafe (e.g., creating and studying the effects of a biological warfare). Random number generation conforming to different probability distributions, discrete-event and continuous simulation, and queuing theory models are of interest. High-performance computing is an area that addresses harnessing the computing power necessary to solve computationally intensive problems by various architectural means such as pipelining, parallelism in processors and input/output devices, and associative memory access. Of late, there has been intense interest in grid computing — efficiently harnessing the collective computational power of the various computers connected via a network. 1.1.14 Social and Professional Issues In addition to the mastery of technical aspects of the discipline, it is equally important to understand the societal and professional implications of the discipline. Knowing the history of computing puts the current state of the field in the right perspective besides an appreciation for the pioneering work of great many scientists, engineers, and mathematicians. It would also be an interesting exercise to imagine how our modern society would have been without computers. Certain people would argue that all these advances are not necessarily contributed to improving the quality of life in general. Think about the societal implication of the Web. It made possible to share and access reference and other information meant for public dissemination instantly for global audience around the clock. It ushered in a short lived era of ``new&quot; economy, and paved the way for electronic commerce as a new channel for sales and marketing. On the flip side, imagine what it would be like if all the businesses were successful electronic businesses (e-businesses). There are no bookstores to go to, and no neighborhood grocery stores to shop in. As a responsible professional, one should ask questions during the design stage of a software system its implications to the human quality of life, or its impact to a particular segment of the society. One needs to be cognizant about the potential risks and liabilities of computer-based systems. No amount of testing can give one an absolute guarantee that a software system is bug-free and safe. One should recognize that there is inherent danger in reusing a piece of software — be it an in-house class library or a purchased component. One should also understand professional code of conduct at work place. What constitutes acceptable use of computers for personal work at office during the working hours and outside the working hours? Does your employer guarantee privacy of your e-mail? Or, is it considered public information within the company? What kind of actions are construed to be discriminatory and harassing at work place? Next there is the issue of intellectual property: copyrights, software patents, and trade secrets. They need to be honored and protected. Consider software piracy, for example. If there are no laws to protect software companies from piracy, think about what it means to the company and you as an employee of the company. One needs to be cognizant of the rights of the software vendor, hardware vendor, and users as well as the rights and liabilities associated with software licensing. Privacy and civil liberties is another issue. A malicious attack on massive databases such as the ones maintained by the Internal Revenue Service poses a serious threat to the privacy of millions of tax payers. Though civil liberties entitles one for free expression in the cyber space, the same privilege can be misused by spreading misleading or false information to incite people for a wrong cause. Of late computer crime is on the rise. It includes spreading the viruses, looking at information for which one has no entitlement, and hacking or breaking into computer systems. There is also an economic aspect related to computing. Issues such as monopolizing the market space by eliminating competition using unscrupulous means, and controlling supply and demand of work force are in this direction. 1.2 Classes of Computers Computers are categorized into two broad groups: special-purpose and general- purpose. Special-purpose computers are specifically designed to solve a pre-determined problem and are optimized for solving that problem. Computers which are part of an embedded system are typically special-purpose type. General-purpose computers, on the other hand, are programmable — they can be made to do things that are not pre-determined. Based on the performance characteristics, size, and cost, general-purpose computers are classified into the following overlapping categories: hand-helds, laptops, notebooks, desktops, servers, workstations, mini-computer, mid-size computer, mainframe computer, and supercomputer. 1.2.1 Hand-Held Computers Hand-held computers are small in size and are meant for use when away from the office. One type of hand-helds are referred to as Personal Digital Assistants (PDAs). They run personal productivity applications such as word processors, spreadsheets, e-mail, and schedulers. They feature functionality to synchronize their contents with a desktop computer. Another type of hand-held, which is more recent, is called the Tablet PC. It is an advanced (wireless) computing device, bringing together the functionality of a laptop and a PDA. 1.2.2 Laptop Computers Laptop computers are small, light weight, full-fledged computers for personal use. They are popular especially among mobile users. More and more workplaces are doing away with the desktop computers in favor of the laptops. This way employees can use the same computer in the office and off-site. Notebooks are predecessors to laptops, and the name is derived from the fact that they look more like (fat Calculus) books in terms of size and perhaps weight. 1.2.3 Desktop Computers Desktop computers are, as the name implies, computers whose size allows them to be housed on a desk. They are typically used to run personal productivity software as well as work related applications in a client capacity (i.e., they are used to run applications by connecting to a server computer). PDAs, laptops, and desktops are called personal computers since their use is limited to only one user at a time. 1.2.4 Server Computers Compared to the desktops, server computers have more processing power and disk capacity. They are used to host software applications such as a database management system, web server, file server, and print server. Servers support several concurrent users, who connect to the server from their desktops, laptops, and PDAs. They are expected to function around the clock to assure high availability. Server computers are generally housed in a secure location such as a server room or data center. A data center is a specially designed building or floor for housing computers. It needs ample air conditioning and Uninterrupted Power Supply (UPS). Physical access to data centers is secured and controlled. 1.2.5 Workstations Workstations, though can be used as general-purpose, programmable computers, their design is optimized for a class of applications. To execute these applications very efficiently, they may have specialized processors and I/O devices. For example, a workstation used for graphics and imaging work, needs special circuit boards or processors and high-resolution display devices for speeding up number crunching operations ubiquitous in processing and rendering graphics and images. Workstations are widely used in Computer-Aided Design/Computer-Aided Manufacturing (CAD/CAM), Computer-Aided Software Engineering (CASE), Desktop Publishing, Molecular Modelling, and Drug Design applications. Like personal computers, workstations are meant for single users. However, they are typically interconnected using a Local Area Network (LAN). 1.2.6 Mini-, Mid-, and Mainframe Computers The distinction between mini-, mid-size, and mainframe computers is based on the number of concurrent users that can be supported. At one end, mini-computers support hundreds of users, while at the other end, mainframe computers can support thousands of users. This class of computers are characterized by powerful processors, enormous amounts of storage space, and round the clock operation. Since multiple users use these computers, security (who can use the system) and entitlements (who can do what) are of high concern. Like server computers, they are housed in a secure location such as a data center. 1.2.7 Supercomputers Supercomputers are the fastest computers and can execute billions of instructions per second. They are used in high-performance computing applications such a nuclear simulation, weather forecasting, fluid dynamics, and computational biology. These applications are characterized by the need for extremely fast computation. From the perspective of supporting large number of concurrent users, mainframes are more powerful than the supercomputers. However, supercomputers can execute a single application faster than mainframes. Supercomputers are also housed in a specially designed space. Because of their potential use for military applications, their sale is governed by the United States government export controls. 1.3 System Software Software is classified into three broad categories: system software, embedded software, and application software. System software includes operating system, compilers, interpreters, assemblers, loaders, linkers, and debuggers. Application software are programs which are designed to solve specific problems and are used by application users. Oracle database management system, Microsoft Word, and are examples of application software. Embedded software is used in embedded systems and it is permanently ``burned&quot; into Read Only Memory (ROM). 1.3.1 Operating Systems As discussed in Section 1.1.5, an operating system is a supervisory program which is responsible for running the computer and managing the applications that run on the computer. Operating system makes it easy to use a computer by providing an abstract layer. Every computer comes with an operating system of some sort. 1.3.2 Compiler, interpreter, and Assembler A computer can execute programs written in its machine language only. These programs are called machine language programs. Applications are generally developed using a high-level language such as C# and Java. Programs written in high-level languages are also referred to as source code. There are two ways to execute programs written in a high-level language: compilation and interpretation. In the first method, a compiler is used to translate the high-level language program into machine language (also known as the object code). An interpreter translates high-level language program into an intermediate form, which it then executes. No machine language program is generated. Compiled programs generally run faster than interpreted programs since the machine language code produced by the compiler is optimized for execution speed. The advantage of an interpreter is that it does not need to go through the compilation stage during which machine instructions are generated. Compilation process can be time-consuming especially for large programs. In contrast, the interpreter can immediately execute high-level language programs. Interpreters are sometimes used during the development stage of a program, during which it is typical to add small sections at a time and test them quickly. Interpreters are also often used in learning environments since they allow students to program interactively. An assembly language is similar to machine language except that the former uses symbols in its program statements instead of binary strings. To execute an assembly language program, first it needs to be converted into an equivalent machine language program. Assembler is a program for this task. In other words, an assembler is to an assembly language what a compiler is to a high-level language. 1.3.3 Loader and Linker A loader is a piece of system software that copies programs from a secondary storage device such as a disk to the main memory, where they can be executed. Each instruction in a machine language program has an address prefixed to it. The address can be thought of a mechanism to uniquely refer to instructions in the program. An instruction references another using its address. Generally the first instruction will have 0 (zero) as its address, the next one will have 1, and so on. Addresses assigned this way are referred to as virtual addresses. In addition to copying a program into main memory, the loader also replaces virtual addresses with physical or real addresses. That is, if the first instruction gets copied to physical address 600, virtual address 0 corresponds to the physical address 600. Physical address of the second instruction is 601, and that of the third is 602, and so on. Most loaders are used by the operating system when needed, and users rarely need to invoke them directly. A large programming project typically involves several software engineers. Each engineer will work on different pieces of code, called modules. Modules are compiled separately thus resulting in several object modules. A linker is used to combine all these object modules to produce a final executable. This process also requires replacing virtual addresses with physical addresses. Linker is also known as link editor, and binder. 1.3.4 Debugger A debugger} is a special program used to find errors (or bugs) in other programs. A debugger allows a programmer to stop a program at any statement using break points* and to examine and change the values of variables. Some debuggers also allow for setting up expressions involving program variables and watching their values as the program executes. Note that a debugger is operating on the machine language program, and not on the source code. A source code-level debugger is one which can help you step through the source program as it executes the object code. This requires the debugger to maintain association between the source code statements in the high-level language program and the associated machine instructions in the object code. 1.3.5 Utilities Utility programs such as e-mail, text editors, hex editors, text processors, spell checkers, and document typesetting also come packaged with an operating system. However, they are not considered as system software. Of late, vendors are unbundling this software from the operating system software as a means to increasing their revenues by separately licensing them. 1.4 Embedded Software Embedded system refers to a computer and software which form a component of some other larger system. An embedded system is physically housed in the larger system. Embedded systems are expected to function without human intervention and respond to events in real-time. An embedded system may include some kind of operating system with very small footprint — often written as a single program. It will not usually have any of the normal I/O devices such as keyboard, monitor, mass storage devices attached to it nor feature any kind of user interface software. A typical system is comprised of a single-board microcomputer with software in ROM (Read Only Memory). ROM is a type of data storage device which is manufactured with pre-determined data and software programs. ROM, in contrast to RAM, is non-volatile — retains its contents even when the power is switched off. Embedded system starts running some special-purpose application program as soon as it is turned on and is typically expected to run forever. Embedded systems abound in practice — in aircraft, spacecraft, automobiles, nuclear power plants, and home appliances. 1.5 Application Software An application program is a software system designed to solve a specific domain problem — for example, payroll, accounts payable, accounts receivable, securities trading, financial portfolio management. They are designed for end users. End users can be human users or other application programs. Application software sits on top of the system software — it needs the services of system software and system utilities in order to run. In the following, we briefly describe some important application software. 1.5.1 Document preparation and Desktop Publishing Of all the computer applications, document preparation or word processing is the most common. Some users of desktop computers spend more time on document preparation than on any other task. Document preparation and desktop publishing are two distinct but related applications. In document preparation, the goal is to quickly produce a document without undue emphasis on esthetics. Programs such as Microsoft Word and WordPerfect belong to this category. Desktop publishing systems, on the other hand, are used to produce documents that rival in quality with those that are professionally typeset. MS Publisher and Broderbund Software’s PrintShop are low-end desktop publishing systems. The ones on the high-end are Open Software Foundation’s , Adobe PageMaker, Adobe FrameMaker, ArborText’s Epic Editor, and Interleaf, Inc.’s Interleaf. Common features found in document preparation software include word wrap, insert, delete, cut and paste of text; search and replace, side-by-side editing of multiple documents, font specifications, spell checking and thesaurus, importing graphics, searching files based on their contents; specification of document layout — margins, headers and footers, page numbering style and location; automatic numbering of footnotes, cross referencing, automatic generation of table of contents and index, and printing. Some allow definition of macros. Macros allow recording a series of actions (can be text or commands) and replaying the sequence repeatedly on different parts of the document to save time and to avoid tedium. Desktop publishing systems provide a full set of features of the document preparation software as well as additional features to provide fine control over placement of text and graphics to enable creating high quality documents such as sales and marketing literature, product white papers, newsletters, and brochures of various sorts. The boundary between the document preparation software and the desktop publishing systems is rather fluid and is constantly shifting with technological advances. Document preparation software is constantly trying to catch up with desktop publishing features, while the latter is relentlessly making new inroads. In general, a document has two aspects: content and layout. Having a clean separation between the content and layout has several advantages. Authors can focus on the content of the document and its structural composition — for example, a book has several chapters, each chapter has multiple sections, a section has possibly many subsections, and so on. A given content and structural composition can be rendered differently by specifying suitable layout options. Layout options for one-sided printing are different from those for two-sided printing. Of late, there is a need for multichannel publishing — traditional print, Web, CD-ROM, and wireless. Separating the content from the layout naturally lends itself for multichannel publishing. We can take the concept of separating the content and its structure from the layout a step further. Under this scenario, content, structure, and layout are orthogonal to each other. A document is produced by first selecting the content, specifying structural relationships among the content items, and finally choosing layout options for rendering the document. Content created in Standard Generalized Markup Language (SGML) format suits this paradigm quite naturally. Large documents that run into millions of pages — aircraft maintenance manuals, for example — are created using this approach. Content is truly treated as a reusable component and its existence is independent of the documents in which it is used. 1.5.2 Presentation and Authoring Software Presentation software is used to create and display highly stylized slides. Basic features include templates and wizards for several classes of presentations, charts and graphs creation, importing graphics, incorporating audio and video clips, formatting and aligning text, spell checker, thesaurus, creating animations and slide shows. Though these presentations can look very sleek, virtually there is no user interactivity. The order in which the slides are shown (navigation path) is pre-defined and hardwired. Changing navigation path to suit a different audience requires physically shuffling the slides, possibly adding some and deleting others since navigation path is simply the physical placement order of the slides in the file. Microsoft PowerPoint is a well-known presentation application. Software for authoring Computer-Based Training (CBT) courses and e-Books, flexible and interactive delivery of product documentation, diagnostic and trouble shooting manuals, help files, and complex technical documents is also considered as presentation software. Hypertext and hypermedia technologies are often used in these systems. With the recent emergence and popularity of multimedia personal computers, there has been a tremendous interest in authoring and delivering on-demand, customized, interactive, and compelling multimedia presentations for multichannel delivery. This poses several challenges including assessing the user need and motivation for the presentation, identifying the appropriate content components, determining pre-requisite dependencies between the content components, and assembling a multimedia presentation on the fly considering the constraints on the length of presentation and the delivery channel chosen. Under this scenario, it is imperative that the content is generated and maintained as reusable components with independent existence. Such systems for automated assembly of presentations feature functionality to support multimedia data, built-in interactivity, templates for common tasks, a repertoire of navigational structures including conditional branching, multi platform deployment, and multichannel delivery. Support is also provided for content versioning and for multiple authors collaboratively creating the content. Macromedia is a leading provider of product suites in this area. 1.5.3 Graphics Program As discussed in Section 1.1.9, there are four broad categories of graphics software: Paint programs, Presentation graphics, Illustration graphics, and Design graphics. We have also described basic characteristics of these categories of software in that section. Design graphics exemplifies high-performance graphics computing. There are four distinct tasks in design graphics applications: modeling, geometric processing, rasterization, and display. Modeling, also known as geometric modeling, involves defining the geometry of the object to be designed using 2D and 3D geometric primitives such as point, line, polygon, circle and ellipse, sphere, curved objects, surfaces, and text. To achieve realism, light source, materials, texture mapping are also specified. The type of projection to be used (orthographic, axonometric, oblique), shading model to be used, and the type of view desired (isometric, perspective) are also specified. All this becomes input to the geometric processor which carries out tasks such as hidden line removal, hidden surface removal, clipping, ray tracing to achieve realistic rendering of the object. Rendered object is still in vector format — a line, for example, is defined by its end points, or by the current position and one other point. However, all modern display devices are raster based. Rasterization is the process of taking the rendered object in vector format and translating it into raster format. Once the rasterization is done, the object can be displayed on any raster output device (monitor, printer, plotter). Geometric processing and rasterization operations are usually implemented in hardware because of their computational intensiveness. Therefore, industry standards are needed for developing portable 2D and 3D graphics applications. OpenGL is such a standard introduced in 1992. It features a rich and versatile application programming interface (API) and brought thousands of applications to a wide variety of computer platforms. The API provides access to geometric and image primitives, modelling transformations, lighting and texturing, anti-aliasing, blending, among others. Every conforming OpenGL implementation includes the full complement of OpenGL functions. OpenGL standard has language bindings for C, C++, FORTRAN, Ada, and Java. Applications utilizing the OpenGL functions are easily portable across a wide array of platforms. Silicon Graphics, Inc. is a premier provider of graphics workstations. Several vendors supply OpenGL API implementation and bindings for popular languages on different platforms. 1.5.4 Image Processing Software Image processing, computer graphics, and visualization are closely related 1.1.9. Computer graphics is concerned with the generation of artifical images. Image processing, on the other hand, deals with processing, enhancing analyzing, and understanding images. These images are not artificial. They correspond to real objects or observed phenomenon. Visualization’s goal is to help understand real-world data collected in numeric or image forms. 1.5.4.1 Image Acquisition and Representation Images are typically obtained by air-borne sensors, areal photography, cameras, frame grabber, scanner, and remote sensing satellites. Some of these are taken in less than ideal conditions. Several corrections are applied to remove ``noise&quot; introduced into the images. Some of the corrections are performed in spatial domain and others are carried out in frequency domain. In the spatial domain, an image representation is composed of pixels arranged in a rectangular array of certain width and height. Resolution of an image corresponds to the width and height of the rectangular array.Pixel depth refers to the number of bits used to represent pixel values. Each pixel represents the brightness of the image at that point and possibly including color information encoded as RGB (Red, Green, Blue) triples. The more the pixel depth, the larger is the range of values which can be used to represent pixel depth — contributes to image quality. Space required to store an image is a function of the resolution and pixel depth. A frequency domain representation is obtained by applying discrete 2D Fourier transform, for example, on the spatial domain representation. Certain tasks which are difficult or computationally expensive in the spatial domain become easier or computationally less expensive in the frequency domain. Using the inverse Fourier transform, the spatial domain representation can be recovered from the frequency domain representation. Frequency domain representations are often used to reduce storage requirements, especially when images are transmitted. Image processing software is usually available as a library of functions implementing the various algorithms including convolution (on which many others are based), Fast Fourier Transformation (FFT), Discrete Cosine Transform (DCT), segmentation, thinning (or skeletonization), edge detection, and contrast enhancement. These are usually implemented in software but may also use special purpose hardware for speed. Many of these algorithms are used for higher level tasks such as image enhancement, restoration, compression and decompression, object recognition, and image interpretation. Silicon Graphics manufactures workstations which are often used for image processing. There are a few programming languages designed for image processing including CELIP and VPL. 1.5.5 Visualization Software Visualization is of great interest in engineering, physical sciences, and medicine. Visualization is used as an effective tool to communicate the knowledge hidden in numbers and mathematical models. The core principles are centered around selecting and arranging image components: color, gray scale, black and white; line types; text for annotation; and background. Effective and limited use of color is important to achieve a visualization goal. Lines can be effective in promoting understanding of the image by delineating object boundaries or regions. Textual annotation of the image should be minimal, otherwise the adage ``a picture is worth a thousand words&quot; is defeated. When properly used, background enhances, supports, and highlights the main components in the image. Like graphics and image processing software, visualization software is computationally intensive, and requires specialized workstations. Most of the visualization work is done at national laboratories of the Department of Energy, NASA, and the National Institutes of Health (NIH). 1.5.6 Mathematical Software Mathematics is a universal language and transcends almost all the disciplines. Mathematical software is widely used for doing mathematics symbolically and numerically, and for exploring and visualizing abstract concepts. It varies in scope and sophistication from being mathematical libraries for a specific subject area of mathematics to comprehensive embodiment of mathematical knowledge. 1.5.6.1 Characterizing Mathematical Software Mathematical software is characterized by using the following facets: coverage scope, access mode, extensibility, interoperability, importing and exporting, visualization, and application development. Scope of coverage is determined by which of the following topics (not comprehensive) are addressed and to what degree: Symbolic Algebra — symbolic math with real and complex numbers, and polynomials, factoring, expansion, and combination, simplification of algebraic expressions and polynomials; Calculus — derivatives, integrals, and limits; Differential Equations — exact and numerical solutions; Partial Differential Equations; Linear Algebra — matrix operations, Eigen vectors and Eigen values; Vector Calculus; Euclidian Geometry; Financial Mathematics; Number, Graph, and Group Theories; Statistical and Data Analysis. Access mode refers to different ways of making use of the software. Some provide libraries, and the functions in the library are invoked from a C or C++ program using the syntax and semantics of library’s Application Programming Interface (API). Others feature a GUI-based workbench within which all the computations are performed. Access through the workbench is ideal for interactive exploration and visualization. Leading mathematical software vendors provide both types of access. Extensibility refers to how the users can extend the functionality of the system. Some systems allow users to add additional capability by developing new programs using the vendor supplied Software Development Kit (SDK). User added functionality seamlessly coexists and is transparent to the other users. Interoperability refers to the mechanisms available in the system to interact with other applications. Some systems allow calling external procedures and integrating with the functionality featured in third-party component-based software. Importing and exporting refers to the aspects of the system that enable importing data from and exporting data to other applications. MathML is an emerging standard for these tasks. Visualization is an integral component of mathematical software to visualize data, concept exploration, and to make the abstract concrete. Graphing, 2D and 3D plotting, different coordinate systems, animation, standard geometric objects, regular solids and polyhedra, and lighting models are functional components featured under visualization. Applications development aspect refers to the availability of tools and programming environments for developing specific applications using the mathematical software. 1.5.6.2 Mathematica, Maple, Matlab, and Mathcad There are scores of mathematical software systems and libraries. Mathematica from Wolfram Research, Maplesoft’s Maple, Matlab from Mathworks, and Mathcad from Mathsoft are well-known and comprehensive systems. Mathematica is programmable in four different paradigms: procedural, rule-based, object-oriented, and functional programming (see Section 1.7. There are hundreds of Mathematica packages available which extend its capabilities. Maple features more than 3,000 computational functions for symbolic and numerical mathematics. Matlab features more than 600 mathematical, statistical, and engineering functions. Toolboxes are collections of highly- optimized, application-specific functions that extend Matlab’s functionality. Scores of toolboxes exist for various application including signal processing, image processing, curve fitting. Mathworks application development tools include the Matlab Compiler and C/C++ Math and Graphics libraries. Forte of Mathcad is its use as an interactive, visual mathematical problem solver with advanced OpenGL compliant graphics and publishing capabilities. JACAL is free mathematical software and its coverage includes Algebra, Calculus, Matrices and Tensors, and Lamda Calculus. It is written in Scheme — an algorithmic, functional language. Scheme installation is required in order to run JACAL. 1.5.7 SpreadSheet Software A spreadsheet is a table of values arranged in rows and columns. Each value in the table is referred to as a cell. A cell is constrained to store values of certain data type only — integers, strings, floating point numbers, dates. Font and formatting information can also be associated with cell data. For example, there are multiple formats to display a date: June 15, 2002; Jun 15, 2004; 06-15-2004; and 15-06-2004. Existence of cells in isolation has only a limited value such as to display information formatted attractively in a tabular format. 1.5.7.1 Cross Linking of Cells What makes a spreadsheet computationally useful is the ability to link a cell with several other cells. For example, the value of a cell can be expressed as a formula composed of values of other cells. If the value of any of the cells participating in a formula changes, the value of the cell gets computed automatically. This capability is used to study “what-if” scenarios. Consider the task of computing a mortgage payment for a home. The variables are cost of the house, down payment amount, mortgage rate, length of the loan, and monthly payment. Monthly payment cell value is expressed as a formula in which the values of the cells corresponding to cost of the house, down payment amount, mortgage rate, and length of the loan are variables. The effect of down payment amount, mortgage rate, and length of the loan on monthly payment can be assessed by varying the values for the down payment, mortgage rate, and length of the loan and noting the change in the monthly payment. 1.5.7.2 Features Spreadsheets programs also provide an assortment of features: copy, cut, and past of blocks of data, edit and validate checks on cell data, spell checker and thesaurus, generating charts and graphs from the data in the spreadsheet, importing data and graphics, conditional formatting of data (e.g., color coding to classify data or to indicate exceptions), sort and filter data, grouping and subtotals. A vast array of functions are also available for use in formula specification. There are financial functions (e.g., straight-line depreciation, net present value, future value, internal rate of return), date and time functions (e.g., date and time arithmetic, converting a text string to date format), mathematical and trigonometric functions (e.g., Sin, Cos, rounding, factorial, logarithmic, combinations and permutations), statistical functions (e.g., mean, mode, average, standard deviation, variance), and string functions (e.g., substrings, searching for string patterns using regular expressions). Spreadsheets usually incorporate a macro language, by which a sequence of actions can be recorded and played back under a macro name to avoid tedium and to save time. Macro language is also used to write user-defined functions from scratch or by composing the functions that come with the system. Microsoft Excel is arguably the most popular and widely used spreadsheet software. It is completely programmable using a macro language or another language known as Visual Basic for Applications (VBA). Using VBA, one can program Excel to communicate with other programs in the Microsoft Office suite — Word, Access, PowerPoint, and Project. The computational paradigm featured in spreadsheets is simple, yet powerful. Because of this and familiarity of the Excel user interface to the masses, spreadsheet computational paradigm has been adopted in designing user interfaces for several business and scientific applications. 1.5.8 E-mail Systems E-mail messaging has become the primary mode of communication in most organizations. It is fast and reliable. E-mail message based evidence is even admissible in courts of law. A company’s e-mail system scope may be limited to within the company or world-wide. In the first scenario, e-mails can be delivered to recipients within the company. In the latter case, the company’s e-mail system is connected to other e-mail gateways so that the messages can be sent to users world-wide. 1.5.8.1 E-mail Message Structure An e-mail message consists of two parts: header and body. Header comprises the name and e-mail address of both the sender and the receiver, time and date when it was sent, and subject. Other headers may get added by different message handling systems during the course of transmission and delivery. Message body is separated from the header by a blank line.Message body can contain not only text but also multimedia data such as audio, video, images, fax messages as attachments. Multipurpose Internet Mail Extensions (MIME) is a standard governing the contents of e-mail message body. 1.5.8.2 Mail System Component An end user program which is used to compose, send, receive, read, forward, and delete e-mail messages is called Mail User Agent (MUA). Popular MUAs for UNIX include elm, mush, pine, and RMAIL; for Microsoft Windows, it is Outlook. After a message is composed, it is handed over by MUA to another program known as Message Transfer Agent (MTA). MTA directly delivers the message if the recipient is local (i.e., within the jurisdiction of MTA). Otherwise, it hands off the message to another MTA on another computer. MTAs communicate using a protocol known as Simple Mail Transfer Protocol (SMTP). The actual message is transported from point to point by a program called the sendmail, which is used in over 75% of all Internet mail servers. Message Handling System (MHS) refers to a family of services and protocols that provides the functions for global electronic mail transfer among local mail systems and MTAs. 1.5.8.3 MAPI Microsoft Exchange is Microsoft’s messaging and enterprise collaboration server. Though the Exchange’s primary role is as an electronic mail message store, it is also used to store calendars, task lists, and contact details. Messaging Application Programming Interface (MAPI) is the messaging component of Windows Open Services Architecture (WOSA). MAPI is a messaging architecture and a client interface component for applications such as electronic mail, scheduling, and calendaring. As a messaging architecture, MAPI provides a consistent interface for multiple application programs to interact with multiple messaging systems across a variety of hardware platforms. 1.5.9 Database Management System A Database Management System (DBMS) is a collection of programs that enable storing, modifying, and querying information from a database. Adatabase is a set of files storing interrelated data. DBMS and database are collectively referred to as database system. There are many different types of DBMSs, ranging from small systems that run on personal computers to huge systems that run on mainframe computers. There are several facets to understanding DBMS: data models, data definition languages, data manipulation languages, logical and physical database design, query languages, transaction processing, concurrency control, data warehousing, on-line analytical processing (OLAP), data mining, distributed and parallel databases. 1.5.9.1 Data models As discussed in Section 1.1.11, a data model is an abstraction for describing information elements, their characteristics, semantics and constraints, and relationships among the elements. There are two categories of data models: logical and physical. Logical models describe the data at a logical or conceptual level. Logical data models are further categorized into object- based and record-based. Object-based logical data models feature flexible and intuitive constructs for modelling the data and allow for explicit specification of data semantics and constraints. Entity-Relationship (ER) model and object-oriented (OO) data model are well-known in this category. Of the two, the ER model is widely used in practice. In contrast to the object-based logical models, record-based logical models are used to specify the structure of the data as well as higher level implementation details. Hierarchical, network, and relational models (in historical order) are the most widely used record-based logical models. Under these models the database is structured as a fixed-format records of several types. Each record type is composed of a fixed number of attributes. Relational data model has taken over the hierarchical and network models in recent years. However, the latter are still abound in older or legacy database systems. Physical data models are used to describe the data at the lowest level.Unifying model and frame-memory model are two such models 1.5.9.2 ER Data Model From the ER model perspective, a domain of discourse consists of a collection of basic objects known as entities. Entities are characterized by one or more attributes. For example, in the university domain, Student and Section are two entities. Student entity is characterized by attributes such as first name, last name, classification, major, date of birth, social security number, and GPA. Attributes course ID, section ID, credit hours completed, semester, year, time, days, and room number characterize the Section entity. Assignment of values to the attributes of Student entity results in an instance of Student entity. Thus, an entity can have many instances. Entities by themselves are not very useful. It is relationships between entities that makes the data more useful. The information that a student can enroll in multiple sections and a section has multiple students is a many-to-many relationship information between the entities Student and Section. Information such as a student should enroll in at least one section and that a section needs at least five students specifies constraints on the relationship. ER models shown graphically are referred to as ER diagram. 1.5.9.3 OO Data Model Object-oriented (OO) model is based on the notion of objects. An object is similar to an instance of an entity in the ER model. An object is characterized by a set of instance variables (or attributes) and the values of the instance variables are stored within the object. While instance variables specify the structure of an object, a set of methods specify the behavior or functional capability of an object. Objects that have the same instance variables and methods are grouped together into classes. A new class (known as derived class) can be obtained from an existing class (referred to as base class) through a mechanism known as inheritance. Derived classes inherit all the structure and functionality of the base class, and can add additional structure and functionality as needed. Inheritance can be extended to any number of levels. One aspect of inheritance is to promote reuse of classes. Classes are also related through each other via various types of associations or relationships. 1.5.9.4 Hierarchical and Network Data Models Hierarchical data models are suitable for applications in which data is inherently hierarchical. For example, an enterprise is structured into various divisions, a division has several departments, and each department has several employees. A domain is modeled as a collection of hierarchies: one for organizational structure, other for product organization, and so on. If we allow a node in a tree structure can have more than one parent, we get a network data model in the form of a graph structure. User queries are answered in hierarchical and network data models by traversing the tree and graph structures. 1.5.9.5 Relational Data Model Table is the prime data structure in the relational model. A table corresponds to either an entity or a many-to-many relationship in the ER model. A table can have multiple columns and column names within a table are unique. One or more columns of a table are designated as primary key of the table. No two rows in the table can have the same values for the primary key columns. This is one type of constraint known as primary key constraint. In other words, values of primary key columns are used to uniquely identify a row in the table. A table can have only one primary key. Relational model also allows other types of constraints on table columns. A uniqueness constraint is specified on one or more columns. Uniqueness constraint specifies that no two rows in the table can have the same values for the columns comprising the uniqueness constraint. Check constraint is another type of constraint which is used to specify that a column can only assume values from a pre-defined set of values. Constraints can also be specified between tables. Such a constraint is referred to as referential integrity constraint. Think of a scenario where a (child) table uses data which actually belongs to another table (parent table). Referential integrity constraint insures that the data exists first in the parent table before the child table can use or refer to it. Indexes are a mechanism available in relational databases to speed up access to table data. 1.5.9.6 DDL and DML Data Definition Language (DDL) specifies precise syntax and semantics for creating tables, specifying constraints, and creating indexes. It is also used to specify parameters for storing the table data — how much of disk space should be reserved when the table is first created, increment size for requesting additional space as the table grows, etc. Unlike the other record- based logical models, queries on the relational databases are specified using Data Manipulation Language (DML) declaratively: what data is needed as apposed to how to retrieve the data. Structured Query Language (SQL) is an industry standard language used in relational databases as DDL and DML. 1.5.9.7 Logical and Physical Database Design Logical database design (in relational model context) focuses on information sufficiency for a given application and insures that the tables are structured in a way to guarantee certain anomalies associated with insert and update operations don’t exist and storing multiple copies of the same data across multiple tables is minimized. Physical database design is concerned with choosing proper storage structures and associated parameters for storing table data, and providing appropriate index structures to optimize access to the data. 1.5.9.8 Transactions and Concurrency Control A transaction is a logical unit of work at the application level. However, a transaction when executed by a DBMS may result in multiple operations at the database level. A transaction manager insures that all operations associated with a single transaction succeed as a unit. If any one of the operations fail, the transaction manager will nullify the effect of previously executed operations related to the transaction. This notion of all or none is critical to insuring data integrity. Concurrency control function insures that the effect on the database by a set of concurrently executing transactions is same as that effected by serially executing the transactions in the set in some order. Concurrency control helps to increase the database throughput (i.e., number of transaction executed in unit time) while guaranteeing data integrity. 1.5.9.9 Data Warehousing and Data Mining Large organizations typically have hundreds of databases scattered across various departments. These databases are designed to meet functional needs of individual departments. However, making decisions at the organizational level requires an integrated access the departmental databases. Data warehousing is an approach to integrating data from multiple, often disparate data sources (i.e., databases based on different data models, legacy applications, flat files). The goal of data mining is to discover implicit patterns in the data. Knowledge derived from such patterns can be used, for example, to promote sales, and to improve customer shopping experience. Suppose data mining revealed a pattern on retail transactional data: whenever a customer bought item \\(x\\), the customer also bought item \\(y.\\) Such knowledge can be used to put item \\(x\\) on sale so that item \\(y\\) can be disposed off quickly. The same knowledge can also be used to shelve items \\(x\\) and \\(y\\) next to each other to improve customer shopping experience. 1.5.9.10 OLTP and OLAP Database applications are classified into two broad categories: on-line transaction processing (OLTP) and on-line analytical processing. OLTP applications are characterized by a large number of concurrent transactions and the design goal is to increase the system throughput. OLAP applications, on the other hand, are designed to support decision making processes at management levels. OLAP queries tend to retrieve and process large amounts of data. Therefore, efficient algorithms for query evaluation and query optimization are of paramount importance. 1.5.9.11 Distributed and Parallel Databases As more and more companies become global, distributed databases are gaining importance. The idea is to fragment and distribute the data in such a way to improve the database performance. However, the fragmentation and distribution should be transparent to the database users. For example, let us say that a company has 100,000 employees, out of which 50,000 work in North America, 10,000 work in Europe, and the remaining work in Asia. It is beneficial from performance point of view, to fragment the data based on geographic regions and create separate databases for managing the fragments. Though this results in three separate physical databases, from the users point of view there is only one logical database. Parallel database systems are enjoying a renaissance due to tremendous interest in OLAP applications. Their goal is to decrease the query execution time and thus improve system response time by various means. Parallelism is also used to provide scalability — ability of the system to handle increased workloads without an increase in response time 1.5.10 Multimedia Information Retrieval Multimedia data encompasses text, graphics, animation, images, audio, and video. The availability of inexpensive and powerful devices for capturing multimedia data has resulted in large repositories. Multimedia information retrieval systems are required to effectively utilize information from these repositories. Functionality of such systems include processing the data to extract information content, structuring and organizing the information content, and processing user queries using the extracted information content. 1.5.10.1 Challenges in Multimedia Information Retrieval Unlike structured data managed by the DBMS, multimedia data poses several challenges. The first issue is in determining what information content in the data is significant in processing user queries. For example, different people will characterize the information content of an image differently. The next issue is how to automatically extract the information content. Despite several years of research in this area, no significant inroads have been made due to intrinsically difficult nature of the problem. Then there is the issue of devising suitable algorithms for processing user queries. Due to the inherent subjectivity in interpreting the image contents, the same query posed by different users need to be processed by taking their subjectivity into consideration by reformulating the query using techniques such as relevance feedback. Multimedia information retrieval is a fascinating area and is in its infancy. In the interest of space, we illustrate retrieval issues in the context of text and images. Text is an example of unstructured data. Traditionally, text retrieval problem has been referred to as information retrieval (IR). IR problem is characterized by a collection of documents, possibly distributed, and a set of users who perform queries on the collection to identify a subset of the documents. This typifies the process you go through in identifying relevant literature for a term paper. Contrast this with the database querying where the query specification is precise and database records are unambiguously characterized by a set of attributes. Users expect retrieved database records to meet the query criteria precisely. On the other hand, database type of retrieval is difficult in IR systems for the following reasons. 1.5.10.2 Indexing Problem Indexing is the process of developing document representation by assigning content descriptors. Index terms are used in assessing the relevance of a document to a query. Retrieval effectiveness is primarily dependent on the quality of indexing. There are two types of index terms: objective and non-objective. Objective terms are extrinsic to the document content and generally there is no disagreement about how to assign them. Examples of objective terms include author name, document title, and publication date.Non-objective terms, on the other hand, are intended to represent the information content of the document. There is no agreement on the choice of terms as well as to what degree the chosen terms reflect the information content. Non-objective terms are called content terms and indexing is assigning content terms to document. Optionally, a weight can be associated with a content term to indicate its importance or relevance in reflecting the information content. 1.5.10.3 IR Models There exists several IR models. An IR model is characterized by four parameters: representation chosen for documents and user queries, strategies for matching query representations with document representations, ranking the query output, and methods employed for acquiring relevance feedback. Unlike the database query results where every record is equally relevant, query output in IR systems need to be ranked based on their estimated relevance to the user query. Because of the issues that result as a consequence of subjectivity and impreciseness inherent in assigning content terms, IR systems often reformulate the query based on user feedback on the initial results and reexecute the query to improve retrieval effectiveness. Retrieval effectiveness is characterized by precision and recall. Recall is the ratio of the number of relevant documents retrieved to the total number of relevant documents in the collection. Precision is the ratio of the number of relevant documents retrieved to the total number of documents retrieved. IR models are classified into four categories: set theoretic, algebraic, probabilistic, and hybrid models. Boolean model is an example of set theoretic IR model. It represents documents by a set of index terms, each of which is viewed as a Boolean variable and is valued true if it is present in a document. No weights are allowed for index terms. Queries are specified as arbitrary boolean expressions formed by linking terms through the standard logical operators: AND, OR, and NOT. Retrieval status value (RSV) is a measure of the query-document similarity. RSV equals 1 if the query expression evaluates to 1; RSV is zero otherwise. All documents whose RSV evaluates to 1 are considered relevant to the query. Vector space model is an algebraic IR model. It is based on the premise that documents in a collection can be represented by a set of vectors in a space spanned by a set of normalized (index) term vectors. If the vector space is spanned by \\(n\\) normalized term vectors, then each document will be represented by an \\(n-\\)dimensional vector. The value of the first component in this vector reflects the weight of the term in the document corresponding to the first dimension of the vector space, and so forth. A user query is similarly represented by an \\(n-\\)dimensional vector. A query-document’s RSV is given by the scalar product of the query and document vectors. The higher the RSV, the greater is the document’s relevance to the query. Extended boolean model is an example of a hybrid model. As in the case of the vector-space model, the extended boolean model represents a document as a vector in a space spanned by a set of orthonormal term vectors. However, it measures query-document similarity by using a generalized scalar product between the corresponding vectors in the document space. 1.5.10.4 IR Software IR software vendors include Excaliber Technologies, Excite, Inc., Fulcrum Technologies, and Open Text Corporation. At the heart of Web search engines is an IR system. Digital Libraries is an application area where IR systems have been extensively used. Oracle, a commercial relational DBMS, provides text indexing, search, and analysis through a feature known as Oracle Text. 1.5.10.5 Image Retrieval Text retrieval is quite advanced compared to image retrieval. Automatically assigning index terms to text documents is routinely done whereas, the same for images is far from being a reality. Existing image retrieval system have used color and texture as content descriptors simply because they are amenable for automatic extraction. However, they perform quite poorly in retrieval task. Often text is associated with images as captions and narrative. In such situations, IR techniques are used to retrieve images based on text, complementing retrieval by color and texture. For example, diagnostic medical images are retrieved not only based on the image contents but also based on other information associated with the images — text describing physician’s diagnosis, treatment plan and the final outcome. Hence, from the physician’s view point, the text associated with diagnostic medical images is as important as the contents of the image itself. Research in image retrieval area has identified several generic query classes for content-based image retrieval (CBIR): query by color, texture, text, shape similarity; spatial similarity — similarity based on directional and topological relationships between the objects in the image. It should be emphasized that true CBIR can only be achieved by synergistically employing various generic query classes in a way transparent to the system user. In other words, high-level user queries need to be expressed as a composition of the generic query classes in a domain-independent way without the involvement of the system user. Video retrieval issues encompass those of CBIR plus additional ones introduced by the spatio-temporal dimension. Virage, Inc. develops and markets CBIR software. Retrieval is primarily based on color and texture. QBIC (Query By Image Content) is an IBM technology for retrieving images based on text, color, and texture. QBIC technology is made available in IBM’s relational database DB2 as DB2 Image Extender. 1.5.11 Geographic Information System A Geographic Information System (GIS) is a computer system for capturing, manipulating, analyzing, and displaying geo-referenced data — data that is tied to spatial locations which are represented by geographic coordinates. GIS data is typically stored as a series of layers. Each layer is depicted as a map and represents geographic features such as soil type, vegetation, annual rainfall, demographics, roads, for example. Each feature is linked to a position on the geographical image of a map — for example, population of a city 1.5.11.1 GIS Use GIS uses are primarily government related including municipal planning, public utility management, environmental protection, natural resources management, and emergency planning. City and town planners use GIS to determine zoning, recreational facilities, utilities, and flood zones. Police departments use GISs to determine the emergency vehicle routes and to compute spatial crime statistics. The census bureau uses GIS to map census data and to statistically analyze the data. Businesses use GIS to determine ideal locations for new stores based on location of competitors, areas of potential customers and their demographics, projected population growth rates, and transportation networks. Geo Positioning System (GPS) in conjunction with a GIS is used in automobile navigation systems. Environmental System Research Institute (ESRI) and ERDAS are leading vendors of GIS software. 1.5.12 Enterprise Resource Planning Systems Software development is time consuming, expensive, and error-prone. Cost overruns, slipping delivery dates, poor quality, functionally deficient, brittle and unstable are the terms often used to describe the experiences with or outcome of software development projects. Furthermore, software needs to be maintained — fixing bugs as they are uncovered in the field. Software needs to be evolved – add additional functionality to accommodate new business requirements. Many companies got disenchanted with the glamor of software development as the promised return on investment was nowhere in sight. Around the same time, some saw a pattern in software development projects across the industry. Company after company was doing the same type of software projects and going through the same frustration and despair. They all need systems for manufacturing — material resource planning, inventory control, distribution and warehousing, sales and marketing; accounting — payroll, accounts receivable, accounts payable; human resources — issuing paychecks, administering employee benefits. Companies such as SAP, PeopleSoft, JD Edwards, Oracle, and Bann develop generic systems for these functions — Enterprise Resource Planning (ERP) systems. Since each company’s business processes, policies and procedures are different, ERP systems are customizable via configuration and extensibility. ERP systems became an instant success in the early 1990s. Several large companies jumped on the ERP bandwagon. Companies license ERP products from the vendors and implement these systems. Implementation refers to installing the generic ERP system and configuring it to reflect the business processes of the company. Figuratively speaking, implementing an ERP system is turning each functional knob of the system to point to certain orientation so that collectively the knob orientations reflect the business processes of the organization. Though several large ERP implementations were successful, it came with a heavy price — implementation costs were an order of magnitude greater than the license costs, and maintenance was a huge recurring expense. There were also instances where many implementations were abruptly aborted. Now companies are showing due diligence and caution in assessing the cost effectiveness of ERP systems. This trend is typical of new technologies, where the reality sets in after a brief period of initial exuberance. 1.5.13 World-Wide Web Related Software We categorize Web related software into two groups: those that are fundamental to enabling Web based computing paradigm and those that are regarded as tools to help build web based applications. In the first category are Web servers and Web browsers. 1.5.13.1 Web Server and Web Browser A Web server is a server process that keeps continuously listening to information requests from clients. Users communicate with the Web server using another program known as Web browser. A browser communicates with the server using a protocol referred to as HTTP (HyperText Transport Protocol). Typically browsers request documents from the Web server. Therefore, a browser usually provides the name of the document that it is requesting. In response, the Web server may simply return a pre-assembled document (also known as a Web page) housed in the server. Such documents are known as static Web pages since their structure and content are determined a priori regardless of who is going to use it. Web pages are authored using a language known as HTML (HyperText Markup Language). HTML comes with a pre-determined set of markup tags. The tags indicate how an HTML document should be rendered for display by the Web browser. There are tags to indicate document title, multiple levels of headings (heading, subheading, sub subheading, and so on). Such tags implicitly designate formatting information — font name, size, type, and color. Tags are also available to indicate formatting information for text that appears in the document body. More importantly, HTML documents can have hyperlinks — a reference from some point in the HTML document to another place within the same document or to a point in another document. A browser usually displays a hyperlink using special formatting. When a user clicks (or activates) on a hyperlink, the browser will display the document pointed to by the hyperlink. 1.5.13.2 Dynamic Web Pages In the early days of Web computing, Web servers primarily provided static Web pages. This was quite useful in disseminating information for public consumption such as technical reports, information about an organization, and its products and services. However, the popularity of Web was so high that it became imperative to explore means to make the Web pages more useful in a business context. The concept of dynamic Web pages was born. Unlike static Web pages, dynamic Web pages are constructed on the fly and contain information which is relevant and customized to the requester’s need. Under this scenario, a browser request will not only name a Web page that needs to be retrieved but also provide necessary parameters to help dynamically generate the page. For example, in an application that provides real-time stock quotes, the parameter will indicate the ticker symbol of the stock. Dynamic Web page generation concept became the seed for electronic business (e-business) or electronic commerce (e-commerce) — selling goods and services using the Web as a channel. Amazon.com pioneered on-line bookstore concept using e-commerce technologies. A new set of tools were introduced to help develop and maintain Web sites. A Web site refers to a collection of things — the computer on which the Web server runs, the Web server, a collection of static Web pages, and optionally additional software or applications to generate dynamic Web pages. ASP.NET from Microsoft and JSP (Java Server Pages) from Sun Microsystems are two widely used technologies for developing dynamic Web sites. Other popular Web related software include e-mail systems (e.g., Yahoo Mail, Hotmail), Web search engines (e.g., AltaVista, Google, Excite), chat programs, and instant messengers. 1.5.13.3 Division of Labor - Thin and Thick Clients In pre-Web era, applications are generally based on an architecture known as client-server. Application functionality is split between two pieces of software referred to as client and server. There are several scenarios for this division of labor. In one scenario, sever does most of the work and the client simply provides user interface for end users to request the functionality of the server. Such clients are called thin clients. Under another scenario, server provides essential services such as accessing the database and implements some of the business functions. Client requests the server for necessary data and performs all computations by itself. Such clients are called fat or thick clients. Advantages of thin client is that since all the business rules and application logic is concentrated in the server software, maintenance and new software releases is limited to just the server machine. Of course, client software needs to be installed on every end user’s desktop. However, client software doesn’t change or needs maintenance as frequently as the server side. On the flip side, thin clients depend on the server for just about anything and thus server may become the bottleneck, making it difficult to scale — ability to accommodate a large number of concurrent users. Thick client scenario reduces the load on the server and scales easily. However, a significant problem is concerned with deployment and maintenance. Bug fix or enhancement releases need to be installed on every end user computer. Think of the effort when your users are situated in multiple locations around the globe. In between the thin and thick client scenarios, one can come up with other possibilities. Web-based applications aim at overcoming problems associated with both the thin client and thick client architectures. For these applications, client is always a Web browser (corresponds to thin client architecture). Thick client scenario is effected in Web based applications by using what is termed browser plug-ins.Browser plug-ins are programs that seamlessly execute within a browser to introduce application-specific functionality into the browser. Plug-ins are hosted on the Web server and automatically get downloaded to the client the first time as well as subsequently whenever a new version of the plug-in becomes available on the Web server. Plug-ins are a means to address deployment and maintenance problems associated with fat clients in client-server based systems. Because of these benefits of Web-based applications, most new systems developed today are rooted in Web-based architectures. It is also not uncommon to re-engineer existing systems to bring them from the client-server world into the Web world. 1.6 Overview of Programming Languages There is an array of programming languages available today for solving problems using a computer. Each language is designed for solving a class of problems. The programming constructs featured by a language for expressing the solution to a problem are directly influenced by the type and abstraction level of the computational steps that are common to the class of problems for which the language is designed. In other words, the language constructs and abstraction mechanisms constrain how a solution to a problem is expressed — that is, the language prescribes the programming paradigm. Programming paradigms are discussed in Section 1.7. Only a small subset of the real world problems are amenable for solution using a computer —- algorithmic problems (see Section ??. The first step in solving an algorithmic problem is to design the algorithm. This is referred to as algorithmic solution. The next step is to express the algorithmic solution using an appropriate language so that it can be executed by a computer. There exists several (programming) languages for this purpose. An algorithmic solution expressed in a programming language is referred to as a computer program or simply a program. Programming languages are differentiated by the programming constructs or control structures they feature, availability of various abstract mechanisms for encapsulating software complexity, and data types, among other things. Language constructs or control structures are the building blocks of the language to encode algorithms (discussed in Chapter ??. There are three fundamental control structures: sequence, conditional execution, and iteration. The sequence control structure denotes that the steps in a computer program are executed in the order of their physical placement in the program. Conditional execution allows for executing one or more steps in the program contingent upon conditions associated with the construct being true. Using the iterative control structure, one or more steps of a program can be executed over and over as long as a specified conditions remain true. There are multiple variations of the last two fundamental control structures. 1.6.1 Computational Completeness and Equivalance Computational completeness of a language refers to the fact that the language is expressive enough to express any solution to an algorithmic problem. A language is computationally complete if it supports all the three fundamental control structures. Two languages are computationally equivalent if they feature the three fundamental control structures. In other words, if an algorithmic problem can be solved using one language, the same problem can also be solved using the other language as well. Certain languages are more appropriate than others for solving a given algorithmic problem. In such cases, the preferred languages have features that are more natural and elegant to express the algorithmic solution. For example, a language may have control structures that are either variations of the fundamental ones or derived by composing the fundamental ones in some fashion so that the resulting control structures have direct correspondence to the algorithmic steps. In such cases, expressing an algorithm in the language is a straightforward process. Otherwise, expressing an algorithmic step may require employing a composition of the fundamental control structures. APL (A Programming Language) language aptly illustrates the case in point. It is designed to manipulate vectors. Adding two vectors in APL is just one assignment statement whereas the same task requires an assignment statement embedded in iteration control structure in programming languages such as C. 1.6.2 Programming languages Continuum Programming languages vary in features widely. They can be best thought of as points on a continuum. At one end of this continuum are machine languages and at the other end are fourth-generation languages (see Sections 1.1.7 and 1.3. Above the machine language is assembly language, and high-level languages are above assembly languages. 1.6.3 Language Elements Viewed abstractly, a computer program is just one large string. The string is broken down into components and components are further broken down into subcomponents, and so on to assess the syntactic and sematic correctness of the program. Rules of syntax define the language grammar — govern how smaller language elements are combined to form larger language elements. Syntax rules are described using a notation referred to as Backus-Naur Form (BNF) (discussed in Sections 3.1 and 3.2. The lowest element types of a language are called words or tokens. Some of these words are predefined and are referred to as keywords or reserved words. The lowest computational unit in a program is called a statement and its types include assignment, IF\\(\\cdots\\)THEN, among others. Control structures define rules for flow of control in executing the statements in a program. A program uses variables to store results of computational steps which appear in program statements. A variable has a type associated with it. The type determines what type of data the variable can hold and permissible operations on the variable. A variable whose initially assigned value never changes is referred to as a constant. 1.6.4 Differentiating Programming Languages Programming languages are differentiated along the following dimensions: general-purpose vs. special-purpose, compiled or interpreted, typed or typeless, types of control structures available, and abstraction mechanisms. A general-purpose language is designed for a broad range of applications whereas, a special-purpose language is designed for a narrow use. For example, C++ is a general-purpose language whereas, SQL is specifically designed as query language for relational databases. There are two ways to execute programs written in a high-level language: compilation and interpretation (discussed in Section 1.3. Some programming languages require all variables and their data types in a program be declared explicitly. Such languages are termed strongly typed. Type information is used to assess data type compatibility in program statements and in converting a value of one type to another. On the other hand, certain languages don’t require type declarations for variables and are referred to as typeless languages. In such languages, a variable can assume different data types during its lifetime. Those that fall in between are weakly typed languages. Though there are only three fundamental control structures, some languages allow multiple forms of a control structure in the interest of naturally expressing the computational steps in the algorithmic solution. For example, some languages allow various forms of repetition control structure — while loop, do while, and for loop. 1.6.5 Which Language is Best? The question of which language is best cannot be answered without considering the problem context. The choice of a language depends on the type of computer the program is to run on, the nature of the problem to be solved, and the expertise of the programmer. Every language has its strengths and weaknesses. For example, FORTRAN 77 is a particularly good language for processing numerical data, but it does not lend itself well to organizing large programs. Pascal is very good for writing well-structured and readable programs, but it is not as flexible as the C programming language, especially for systems programming. C++ embodies powerful object-oriented features, but it is fraught with cryptic syntax and is difficult to learn. C# combines desirable object-oriented features of C++ and the event-driven programming ease of Visual Basic. Abstraction mechanisms are needed to contain the complexity of large programs, and to improve program maintainability. Procedure or function is one such procedural abstraction where a set of statements are grouped under a name. A procedure or function solves a well-defined, small task in the domain and is invoked by other statements in the program. The procedure is often parameterized meaning that its computational behavior can be altered in pre-defined ways depending upon the values assigned to the parameters during its invocation. Other abstraction mechanisms include classes, modules, and components. 1.7 Programming paradigms At the highest level, there are two programming paradigms: imperative and declarative. 1.7.1 Imperative Paradigm Imperative style of programming is procedural in nature. A program consists of a number of statements that specify how a particular task gets accomplished. Another way to look at imperative programming is that it describes a system as evolving from an initial state through a series of state changes to a set of desired final states. For example, the statement ``DaysWorked = DaysWorked + 5,&quot; will take the system from its current state (in which the variable DaysWorked has some value) to a new state in which the variable DaysWorked has a value five more than the value of DaysWorked in the previous state of the system. Imperative languages are also known as procedural languages. C++, C#, and Java are procedural languages. 1.7.1.1 Classical Procedural Languages Procedural languages require imperative style of programming. FORTRAN, COBOL, and C are other examples of classical procedural languages. FORTRAN is an acronym for FORmula TRANslation and is used in science and engineering applications. It is the oldest high-level programming language. COBOL is an acronym for COmmon Business Oriented Language. It was developed in the early 1960s. It is the second-oldest high-level programming language. It is particularly popular for business applications that run on mainframe computers. COBOL programs are verbose. Therefore, they tend to be much longer than the same programs written in other languages. However, the wordiness makes it easy to understand COBOL programs. COBOL is still one of the most widely used programming language. In contrast with COBOL, C is a very compact in its syntax. It is widely used for systems and applications programming. 1.7.2 Object-oriented Languages Object-oriented programming languages are also procedural languages. Object-oriented programming is based on the notion of an object and related concepts. An object is an abstraction that represents a real-world thing. An object is characterized by its structure, behavior, and identity. Structure of an object is specified by variables, and its behavior (or functional capability) is manifested by the methods associated with the object. Each object is required to be uniquely identified by some identification mechanism. All objects with identical characteristics are grouped into a class. The objects are referred to as the instances of the class. Consider a Student object in the university environment. The object state is characterized by student ID, social security number (SSN), student name, major, classification, date of birth, hours completed, and GPA. Possible object methods are: computing age and GPA. Though we can assign attributes such as StudentID or Social Security Number (SSN) as object identifiers, usually identifiers are system generated ones that are guaranteed to be unique. Once an identifier has been assigned to an object, it never changes. This is one of the reasons why we don’t want to assign StudentID or SSN as object identifiers. The collection of all Student objects constitutes the Student class. A single class by itself has limited functionality. Complex systems are built by employing several classes. An object of a class requests services of another object belonging to a different class by sending a message to the latter (referred to as message passing). New classes are created from existing classes using a mechanism known as inheritance. The new class inherits all the structure and functionality of the class from which it is inherited. In addition, the new class can selectively override the inherited functionality as well as extend the functionality by adding new variables and methods. One of the principal advantages of object-oriented programming techniques over classical procedural languages is that the object-oriented programs are easier to modify and maintain. There are several object-oriented programming languages including Smalltalk, C++, Java, and C#. 1.7.2.1 Scripting Languages In the simplest sense, a script is a sequence of statements executed by an interpreter. Languages which are used to write scripts are called scripting languages. Scripts are used as a glue to effect interoperability between various applications, and functions featured by the scripting language itself. Examples include UNIX Shell scripts and MS DOS batch files. Scripting languages are weakly typed or typeless and has little or no provision for complex data structures. Other scripting languages include VBScript, JavaScript, Jscript, and Perl. Script languages assumed more prominence and widespread use in the context of Web programming. VBScript (Visual Basic Script) was developed by Microsoft. Internet Explorer Web browser can execute VBScript programs. VBScript is based on the Visual Basic programming language. It enables Web authors to include interactive controls, such as buttons and scroll bars, on Web pages. JavaScript was developed by Netscape to enable Web authors to develop interactive sites. It is supported by the recent browsers from Netscape and Microsoft. However, Microsoft Internet Explorer supports only a subset of JavaScript, which Microsoft refers to as JScript. Perl (Practical Extraction and Report Language) is an scripting language designed for processing text. Because of its strong text processing abilities, Perl has become one of the most popular languages for writing CGI scripts (required in developing dynamic Web sites). 1.7.2.2 Markup Language These languages are used to markup documents of various sorts for different purposes. Markup may be done to indicate how a document should be rendered for display purpose as in the case of HTML (HyperText Markup Language). Markup may also be done to indicate both logical structure and layout information (i.e., typesetting) as in the case of . Standard Generalized Markup Language (SGML) is a generic language for representing a document’s content, its logical structure, and the relationships between the content and the logical structure. SGML allows document-based information to be shared and re-used across applications and computer platforms in an open, vendor-neutral format. XML (eXtensible Markup Language) is a new markup language introduced recently that has gained prime importance in e-commerce applications. XML is based on SGML. 1.7.2.3 Page Description Language Page Description Languages (PDL) are used to describe the layout of documents for display and printing in a manner that is independent of the original application software, hardware, and operating system that was used to create those documents. Adobe PostScript and Hewlett-Packard PCL (Printer Control Language) are PDLs used to control laser printers. Both PostScript and modern versions of PCL are object-oriented. They describe a page in terms of geometrical objects such as lines, arcs, and circles. Portable Document Format (PDF) is a native file format for Adobe Systems’ Acrobat. A PDF file can describe documents containing text, graphics, and images in a device- and resolution-independent format. PDF supports color and is very compact in terms of storage requirements. PDF documents can be extremely large running into tens of thousands of pages. Displaying and printing using PDL is a two-stage process: an application program first produces document layout description in PDF language, which is then interpreted by a specific output device. PDLs, therefore, serve as an interchange standard for transmission and storage of printable documents. 1.7.3 Declarative Paradigm Declarative style of programming focuses on specifying what needs to be accomplished, rather than how it will be accomplished. It can be thought of as specifying relationships between different variables in terms of functions or inference rules. Interpreter or compiler applies some fixed algorithm to these relations to produce a result. Consider the statement ``DaysInWeek = DaysInWorkWeek + 2.&quot; It declares DaysInWeek to have a value of two more than the value of DaysInWorkWeek. Variables, once declared or initialized, cannot change their value. There is no concept of states and state transitions. The most common examples of declarative languages are logic programming languages such as Prolog and functional languages like Haskell. 1.7.3.1 Functional Languages athematically speaking, a function is a rule that transforms input into unique output. In other words, it is a relationship between a set of inputs and an output. From programming perspective, a function is regarded as an operation, which when passed specific values as input produces output. Functional programming is a type of declarative programming in which functions are treated as first-class objects meaning that (among other things) functions can be passed as arguments to other functions. A function can also return another function as its result. A program in a functional language consists of a set of (possibly recursive) function definitions and an expression whose value is output as the program’s result. They are based on typed lambda-calculus with constants. There are no side-effects to expression evaluation so an expression will always evaluate to the same value. An expression can always be replaced by its value without changing the overall result. Programs written in a functional language are generally compact and elegant. Until recently, they tended to run slowly and required a lot of memory. Examples of functional languages are Clean, FP, Haskell, Hope, LML, Miranda and SML. Other languages such as Lisp have a subset which is purely functional but also contain non-functional constructs. LISP is a high-level programming language especially popular for developing artificial intelligence applications. Some mathematical computing systems such as Maple feature functional programming. 1.7.3.2 Logic Programming Language Logic programming is also a form of declarative programming. Logic programs are specified by listing facts and rules in the problem domain. Computation takes the form of answering user queries, which usually require yes/no type answers or assigning constants to variables so that the rules in which the variables are used evaluate to true. Application independent rules of inference are used in answering user queries. Inference can proceed in top down (goal-driven) or bottom up (data-driven) fashion. PROLOG (PROgramming LOGic) is a high-level programming language based on formal logic. It is used widely in artificial intelligence applications, particularly in expert systems. 1.8 Abstract Machine Hierarchy he innate abstraction level of interface to a computer is at too low-level, which makes it hard to use. To raise the level of abstraction and to increase human productivity with computers, the notion of abstract machine hierarchy is introduced. An abstract machine hierarchy consists of a number of layers and each layer corresponds to a virtual machine except the bottom layer which corresponds to a real, physical machine. All machines have a programming language associated with them. As we go up from bottom layers to upper layers the corresponding virtual machines become more and more abstract. That is, a virtual machine’s computational steps closely reflect the computational steps that are natural to the application domain. Thus, application development becomes easier as there is less semantic gap between how a user views the computation in the domain and the way they are expressed in the virtual machine’s programming language. Translators are needed to translate programs in the language of virtual machine at layer \\(n\\) into the language of the machine at layer \\(n-1.\\) There are a few advantages to the abstract machine hierarchy. First, it provides users high-level abstractions to make the programming task easier and the resulting complexity is absorbed by the layers in between the top and bottom layers. Second, it also helps to develop software that is independent of platform and operating system specific considerations by using the higher level abstractions in the machine hierarchy. Cases in point are Microsoft Intermediate Language (MSIL) and Java Bytecodes. When a program is written in C#, first it is converted into an intermediate language, MSIL. Just before the program is run, an optimized machine language program is produced from the MSIL version by taking into consideration the characteristics of the target environment — the environment of the machine and the operating system under which the program will run. Same is true for programs developed using the Java language, the intermediate language representation being the Java bytecode. A disadvantage with the abstract machine hierarchy is that the programs will run slower as they need to go through translations between the layers. 1.9 Chapter Summary Computer Science is a broad discipline with a strong and coherent conceptual core. Subareas of computing discipline include Discrete Structures, Programming Fundamentals, Algorithms and Complexity, Architecture and Organization, Operating Systems, Net-Centric Computing, Programming Languages, Human-Computer Interaction, Graphics and Visual Computing, Intelligent Systems, Information Engineering, Software Engineering, Computational Science and Numerical Methods, and Social and Professional Issues. From an end user perspective, there are three aspects: physical computers, system software, and application software. There are various classes of computers ranging from hand-helds to supercomputers with varying price and performance characteristics, each targeted for a specific market segment. System software includes the operating system, compilers, interpreters, assemblers, loaders, linkers, and debuggers. End users, though interact with the operating system through a command-line or graphical user interface, by and large the system software is of interest to application software developers. Practical applications of computers are far and wide. They range from a simple word processors to sophisticated enterprise resource planning systems. Embedded software is a special type of software used in embedded systems. It is permanently built into Read Only Memory (ROM) and controls the system into which it is embedded. Web related software include Web server, Web browser, and application-specific browser plug-ins. Web servers and browser use HTTP is a standard protocol for their communication. ASP.NET and JSP are two widely used technologies for developing Web based applications. There is a large assortment of programming languages. Each language has its own strengths and weaknesses. Which language is appropriate for a given problem is dependent on the nature of the problem, the computer on which the program will run, and the expertise of the programmer. Any programming language that supports three fundamental control structures — sequence, conditional, and iteration — is computationally complete. That is, the language has sufficient expressive power to encode solution to any algorithmic problem. There are two styles of programming: imperative and declarative. Imperative style of programming requires detailed specification of steps involved in solving a problem. All procedural languages are imperative. They include classical languages such as FORTRAN, COBOL, C as well as object-oriented programming languages such as C++, Java, and C#. There are also scripting languages which act as a glue in providing loose interoperability between various application components. Scripting is quite popular in UNIX environments in which various script interpreters are provided (e.g., Bourne Shell, C Shell, Korn Shell). Script languages such as VBScript and JavaScript are used in developing interactive Web applications. Markup languages are used to markup documents for various purposes including specifying the logical structure of a document (as in SGML), specifying both logical structure and rendering information (as in ), and rendering information only (as in HTML). XML is a recent markup language which is used to specify both the document structure and data semantics. Page description languages are used to describe page layout and rendering information in an application- and platform-independent manner. Examples of this category include Hewlett-Packard’s PCL and Adobe System’s postscript language and PDF. Declarative style of programming requires specifying only the problem that needs to be solved. Examples of this category include functional programming languages such as Miranda and SML; logic programming languages such as PROLOG. Abstract machine hierarchy helps to provide a high-level of abstraction in interfaces for interacting with computers. It also helps to develop software in a way independent of platform and operating system issues. The Joint Task Force on Computing Curricula 2001 refers to this subject area as Information Management. However, we think that it is a misnomer.↩ There are many flavors of UNIX such as Sun OS, IBM AIX, HP UX, and Linux.↩ "],
["IntroObjProbSolv.html", "2 Object-oriented problem Solving 2.1 Concept Map 2.2 Procedural, Data, and object Abstraction 2.3 Object-Oriented Concepts 2.4 Unified modeling Languages 2.5 Investment Management Application Domain 2.6 Investment Management Application 2.7 Chapter Summary 2.8 Exercises", " 2 Object-oriented problem Solving Almost all large-scale software systems developed today are based on Object-Oriented (OO) paradigm — system is structured as a set of objects communicating with each other via messages. This paradigm is a successor to procedural and data abstraction based software development. This chapter provides a conceptual introduction to OO concepts and OO problem solving. Therefore, objectives for this chapter are to: Briefly describe procedural and data abstractions. Present fundamental OO concepts: object/class, messages, class relationships, polymorphism, and interfaces. Introduce Unified Modeling Language (UML) as a means to document various artifacts of object-oriented analysis and design (OOAD), system packaging and deployment activities. Describe investment management application domain to help reinforce the OO concepts. Explore and examine the completed investment management application (implemented in C#) to get a deeper understanding of the domain as well as to perform requirements traceability analysis — assessing to what degree the completed application has implemented the requirements. 2.1 Concept Map Object-Oriented Paradigm Abstraction Procedural Data Object Domain Class Object Structure Behavior Unique Identity Template/Blueprint Interface Service Operation Operation Signature Parameter Parameterization Direction Type Default Value Visibility Fields Static Instance Data Members Methods Header Signature Return Type Body Instance Methods Static Methods Member Functions Modifier Methods Query Methods Utility Methods Structural Characteristics Behavioral Characteristics Encapsulation Information Hiding Separation of Concerns Object State Type Class Constraints Assertion Pre-condition Post-condition Invariants Object Constraint Language (OCL) Class Diagram Conceptual Perspective Specification Perspective Implementation Perspective Message Sender Receiver Synchronous Message Asynchronous Message Method Header Signature Polymorphic Virtual Sealed Overloaded Class Relationships Association Cardinality Multiplicity Optionality One-to-one One-to-many Many-to-many Binary Ternary \\(n\\)-ary Recursive Dependency Aggregation Container Class Contained Class Composition Container Class Contained Class Delegation Generalization Specialization Inheritance Substitution Principle Implementation Inheritance Interface Inheritance Single Inheritance Multiple Inheritance IS-A Relationship HAS-A Relationship KIND-OF Relationship Method Override Polymorphic Method Virtual Method Root Class Base Class Parent Class Super Class Subtype Derived Class Child Class Leaf Class Sealed Class Unified Modeling Language (UML) Object Management Group (OMG) Unified Process (UP) Rational Unified Process (RUP) Use Case Scenario Main Flow Alternative Flow Exceptional Flow Use Case Relationships Generalization Include Extend Extension Points Use Case Discovery Actor-Based Event-Based Requirements Traceability Analysis Test Case Development UML Diagrams Use Case Diagram Class Diagram Object Diagram Instance Diagram Sequence Diagram Collaboration Diagram Activity Diagram State Diagram Component Diagram Deployment Diagram 2.2 Procedural, Data, and object Abstraction In the early days of computing, computers were primarily used for number crunching applications that are abound in military and scientific applications — trajectory computation, mission planning and simulation, and weather forecasting, among others. Algorithmic problem solving techniques were heavily used and were appropriate. The programs were written as large monolithic pieces, often abound with code repetition. Then the notion of procedural abstraction was introduced to remove code repetition. A block of code that is used repeatedly in the program is separated out, given a name, and is called from the program whenever necessary. The separated piece of code is referred to as a procedure or function. Procedures and functions were parameterized to make them more versatile. For example, a function to compute monthly payments of a car loan needs loan amount, length of loan period, and interest rate as parameters. Such a function is more useful than the one without parameters. In the latter, the parameter values are hard coded into the program. The program needs to be changed if we want to compute monthly payments for a different combination of parameter values. Though procedural abstraction is helpful in hiding the implementation details of the procedure, it is not that effective in the grand scheme of very large programs. In traditional programming, there is a clear distinction between program instructions and data. Because of this dichotomy, which program instructions modify what data is not apparent. If the data format or data types change, you need to scan the entire program to locate the instructions that reference the changed data and suitably modify them. Data abstraction takes procedural abstraction one step further by packaging relevant instructions and data together. That is, it encapsulates a set of data and provides a controlled mechanism or services to manipulate the data. The only way to access and manipulate the data is by invoking the services. This guarantees controlled access to the data. Object abstraction takes the data abstraction concept a step further by introducing class, object, message, relationships, polymorphism, and interface concepts. A primary goal of OO techniques is to minimize and isolate changes to programs when program logic or data changes. In other words, instructions and the data they operate on is treated as one inseparable unit. Therefore, introducing a change is not as expensive and error-prone as in the case of the traditional methods. 2.3 Object-Oriented Concepts Object-oriented (OO) techniques provide a framework for solving problems using object abstraction and related concepts. The concept of class, which is at the core of OO techniques, was first introduced in 1960s in Simula — a programming language. Simula is an acronym for simulation language and was intended for simulating complex, real-world systems. In such systems solutions are centered around the notions of object and class. In simulating a commercial airport, for example, passengers, aircraft, gates, runways, security check points are some of the objects. A set of objects with identical structural and functional characteristics (or responsibilities) are grouped under a class (Figure 2.1. For example, all passengers belong to Passenger class; individual passengers are instances of the Passenger class. In other words, a class prescribes a template, and instances of it represent instantiations of the template by assigning values to the attributes that comprise the class structure. If the distinction between various types of passengers is important (e.g., first class, business class, coach class), specialized classes of the Passenger class such as FirstClassPassenger and BusinessClassPassenger are created. Figure 2.1: Passenger Class The way we live our daily lives is a perfect example of OO way of problem solving. We interact with and seek services of other objects — teachers, doctors, banks, Real estate agents, travel agents, to name a few. We only need to express what services we need from an object to receive them. We are not concerned with the techniques or procedures employed by the object to fulfill the requested service. Each object specializes in what it does and provides services in a transparent manner to the requester. Organizing a solution to a problem around classes contributes to containing the complexity of the problem through suitable domain abstractions 3 (e.g., Teacher, Doctor), encapsulation (i.e., the process of packaging data and code that manipulates the data into an integrated element) and information hiding (i.e., hiding implementation details), and separation of concerns (e.g., a teacher neither need to know nor worry about how a travel agent does her job). If a travel agent comes up with a better technique to perform her job, the rest of the world need not change their ways of interacting with the travel agent. The only change that this may have on the requester is a better or faster service. To appreciate the value of OO way of developing applications, consider shopping in a retail store such as Wal-Mart vs. a pharmacy. If an item in a retail store is moved to a different location from the location you usually find it at, then you may go around the aisles to locate the item yourself. If you don’t find the item before your patience wears off, you may seek the assistance of a sales associate. In some cases, the sales associate herself may have to engage in the same process that you went through unsuccessfully. Contrast this with buying prescription medicines in a pharmacy. You are not concerned about where the medicine is shelved, whether it is pre-prepared or made after your request, or even brought from another pharmacy. Except for the waiting time, you don’t care about how the prescription is filled. Analogically speaking, shopping in Wal-Mart is akin to traditional programming, whereas buying a prescription medicine is akin to OO way of developing software. Each item relocated in Wal-Mart corresponds to one software change request (to fix a defect or to add a new feature). What would your shopping experience be like if the items are relocated often and too many of them at a time? Wal-Mart effectively controls the relocation of items, but unfortunately in software development changes are a fact of life. Using encapsulation and information hiding principles in OO way, the effect of the changes to a piece of code are localized and are transparent to other programs that use this piece of code. A caution is in order. OO techniques are not a silver bullet for all the problems plaguing the software development. Its effectiveness lies in mastery of the techniques, which enable you to decide when, where, and how to use them; mere pedagogy may do more harm than good. 2.3.1 Objects and Classes An object is an abstraction of a real-world entity, or a concept. Recall that abstraction principle emphasizes those aspects of a problem (domain) relevant to the task at hand while deliberately suppressing the irrelevant details. Abstraction helps in understanding of the problem and hence facilitates coming up with a solution. It is possible to have multiple abstractions of a domain, each one emphasizing certain aspect of the domain. For example, consider the human body. It is one of the most complex in terms of both structure and function. To understand its form and function, several abstractions have been developed: nervous system, circulatory system, digestive system, respiratory system, among others. Objects are self-contained units, have crisp boundaries, and provide a well-defined set of services. An object has structure (or state), behavior (or functions/responsibilities), and a unique identity. Objects abound in our daily lives. For example, consider passenger cars. Regardless of which car we look at, the fundamental abstractions are the same — steering wheel, gear control, speedometer, turn indicators, window controls, door locks, to name a few. The implementation of these abstractions may vary, for example, electrical vs. mechanical. However, the purpose of these fundamental abstractions remain the same. This is why it doesn’t require any additional training or effort to drive a new or unfamiliar car. The same thing can be said about household appliances such as ovens, dish washers, and washing machines. The interface — controls available to the users to operate the appliance (e.g., cycle selection, load size) — is specified and implemented at a level of abstraction which is meaningful to the users. They need not know anything about how the interface has been implemented. As noted earlier, a class denotes a group of objects that have same responsibilities, structure, and relationships (with other classes). It specifies a template or a blueprint for objects. An object is a specific instance of a class obtained by assigning values to the class attributes which characterize the object state. Right hand side of Figure 2.2 depicts two instances of the Passenger class. The process of creating an instance of a class is referred to as instantiating the class. It involves allocating memory to represent the attributes of the object and initializing them. Figure 2.2: Passenger Class and its Instance The notation for objects is: objectName:className (i.e., the object name followed by a colon and the class name) or simply :className. Also, notice that the schematic for representing classes used in Figure 2.2 is different from the one shown in Figure 2.1. The latter form is used to emphasize that access to the attributes of a class is guarded. However, the graphical notation used in Figure 2.2 is more convenient to depict class attributes and responsibilities. The schematic for class is divided into three regions: class name is indicated in the top region, the middle region shows attributes, and the lower region enumerates responsibilities. A class has certain responsibilities or functional obligations. All instances of the class have the same responsibilities. This is why the responsibilities are not shown for object instances in Figure 2.2. Responsibilities are manifested in the form of services. For instance, the Passenger class’s responsibilities include making and updating reservations for trips, buying tickets, retrieving itinerary for a given trip, tracking baggage, finding flight status, and changing/setting passenger name. In other words, services fulfill the responsibilities of a class. An abstract class is one which cannot be instantiated. It is created solely for organizational purposes — to specify common structure and behavior, which other classes can inherit from. 2.3.2 Class Structure and Responsibilities Structure or state of a class is specified by a set of attributes. For example, the Passenger class shown in Figure 2.1 has SSN, Name, Address, Phone, Itinerary, and Status attributes. Some of these attributes assume atomic values (e.g., Name is a character string) whereas, others represent more complex values (e.g., Itinerary is a collection of trips, each trip may consists of multiple flight segments). The Itinerary attribute itself is an instance of some other class. Attribute values collectively manifest the state of an object at a point in time. Transition of an object to a new state is reflected by changing the values of one or more attributes. For example, a Passenger object can be in one of the following states: holding reservation, ticketed, boarding pass issued, on board, trip completed. Status attribute value indicates the current state of the Passenger object. However, in the general case, object state transition may result from several attribute value changes. State transition is typically caused by events occurring within or outside the object. We reemphasize that in Figure 2.1, services are shown as encircling the attributes to underscore the fact that the services carefully guard access to the attributes. In other words, the only way to get access to the attribute values is to channel the requests through the services. They promote the view that you need to know only the services of a class (i.e., what does a class do?, and how to invoke a service?) to make use of its services and that the attributes are internal to the class. This enables a class to change its state representation techniques as well as the algorithms to implement its services without affecting the users of the class. In the OO literature, a class is also referred to as a type. It is preferred by some in that it is not tied to any implementation aspects. On the other hand, the term class is less precise in that it refers to both a domain concept and its corresponding implementation in a programming language. 2.3.3 Class Diagrams A class diagram depicts classes and static relationships (associations, generalization/specialization, aggregation, and composition) between the classes (discussed later, see Figure ?? for an example). Classes in a class diagram are interpreted from three different perspectives: conceptual, specification, and implementation. 2.3.3.1 Conceptual Perspective From a conceptual perspective, classes in the class diagram represent domain concepts and various relationships between them. For example, a Passenger object has name, phone number, and address. Though attributes characterize the concepts, we don’t focus on them at this point. Services indicate the responsibilities of the class. Initial class diagrams should be developed from a conceptual perspective. Issues related to the programming language or other software that will be used to implement the classes should not be considered at this stage. Therefore, conceptual-level class diagram is language-independent. It should depict only responsibilities of classes and relationships between them. Figure ?? is an example of a conceptual-level class diagram. It doesn’t show responsibilities for space reasons. 2.3.3.2 Specification Perspective The focus under this perspective is on rigorously specifying software interfaces (discussed in Section ?? so that other classes can request the services of the class under consideration. There should be no implementation considerations at this stage. A Passenger object is viewed as having capabilities to retrieve its name, change its name, for example. Attributes have unique names and are associated with types (e.g., integer, float, string, class). Default values, rage of values (e.g., minimum and maximum), and edit and validate checks (e.g., what type of strings are considered as valid dates?) are associated with the attributes. Relationships between the classes are considered as responsibilities of the classes. From the specification perspective, services are referred to as operations. Operations that are meant for consumption by other classes only are shown. UML (discussed in Section 2.4 syntax (simplified) for specifying operations is: visibility operation_name (parameter_list): return_type. This is referred to as operation signature. Visibility specifies access restriction: public — can be invoked by any class; protected — operation can be invoked by only those classes which are more specialized versions of the class; private — operations are for private use of the class only. Operation name is unique within the class and requires zero or more parameters. For example, invoking fltStatus operation requires flight number and date as parameters. Multiple parameters are specified using comma as a delimiter. The order of parameters is important. The syntax for specifying a parameter is: direction name: type [= default_value], where direction can assume one of the three values: in, out, inout; name refers to the parameter name; type indicates parameter’s type; finally, the default_value is used when the parameter value is not supplied. If direction is not specified, in is assumed and the default_value is optional. For example, in fltNumber: string and in date: DateType = today, specify two parameters named fltNumber and date. Both have in direction (i.e., the invoker need to provide values for these parameters), the first is of string type and the second is of DateType. Today’s date is used as default for the second parameter in case that the invoker doesn’t provide a value. The value returned by an operation is specified by return_type. 2.3.3.3 Implementation Perspective This is a widely used perspective. It specifies a class from an implementation view point. Often this perspective is tightly associated with an object-oriented programming language. Attributes are referred to as fields or data members. Operations are referred to as methods or member functions. Private and protected methods are also shown in addition to the public ones. Corresponding to every operation at the specification level, there is a method which implements the operation. There are three general categories of methods: modifiers, query, and utility. Modifier methods alter attribute values. Typically, they don’t return values with the exception that boolean values may be returned to indicate success or failure of the method. Modifier methods are also known as set methods. Query methods simply return values of attributes (i.e., they don’t alter attribute values). The returned value may be that of an attribute, or may involve an elaborate computation involving other attributes. The query methods are also referred to as get methods. Utility methods are helpers in implementing set and get methods. A method has two parts: signature and body. Method signature specification is identical to the specification of operation signature. In some OO programming languages, a distinction is made between method signature and method header. The former doesn’t include the method return type, while the latter does. Method body is the actual code which implements the method. A class can change the implementation of its methods without affecting the users of the method provided that the method signature remains intact. Method signatures collectively specify the class’s interface to the outside world. Interfaces should reveal as little as possible about internal workings of a class. The three perspectives are summarized in Table 2.1. Class diagrams from the conceptual perspective are developed first. They are evolved into class diagrams from the specification perspective by formalizing operation signatures. Finally, implementation-level class diagrams are obtained from the ones at the specification-level by considering implementation details. This distinction is important for OO development. Unfortunately, it is often overlooked in practice by mixing specification and implementation. Table 2.1: Multi-perspective view of a class Perspective Focus Structure Functionality Conceptual Conceptual understanding of the domain in an implementation independent context. Classes are viewed as domain concepts and relationships between the concepts. Attributes characterize domain concepts. Class functionality is specified in terms of responsibilities or services. Specification Rigorously specifying class interfaces in an implementation-independent way. Attributes characterize class state. Attributes have unique names and are associated with types, default values, a range of allowable values, edit and validate checks. Class functionality is specified in terms of operations. Only those operations meant for consumption by other classes are shown. Operations are specified with complete signature. Implementation Implementation-oriented specification of a class targeting class implementors. Fields or data members characterize class state. Methods or member functions specify class functionality. 2.3.3.4 Modeling Classes A good starting point for modeling classes is to start with their responsibilities. Each class has one or more responsibilities. A responsibility is a contract or an obligation of a class. The attributes and operations of the class are means to fulfilling the class’s responsibilities. CRC (Class, Responsibility, Collaboration) is a technique for identifying the initial set of classes. CRC cards are discussed in Section ??. 2.3.4 Fiels and Methods: Instance vs Static There are two types of fields: instance and static. Values of instance fields are specific to each object. In the case of Passenger class discussed earlier, fields such as social security number, name, and address are specific to each object and hence they are instance fields of the Passenger class (Figure 2.1. Static fields, on the other hand, are at the class-level and are shared by all instances of a class. For example, we can have a static field called numPassengers to keep track of the number of instances of the Passenger class. Like fields, there are two types of methods: instance and static. Instance methods are invoked on an object instance. They can access both instance and static fields. Static methods, on the other hand, are invoked using the class name and can only operate on the static fields. 2.3.5 Class Contraints Classes can also specify constraints — conditions that the class or users of the class should satisfy. If class A is associated with two other classes B and C, and this association is mutually exclusive (i.e., an instance of A can only be associated with either an instance of B or an instance of C, but not with both of them simultaneously) is indicated by a condition. More complex conditions are expressed using UML’s OCL (Object Constraint Language). Often constraints are specified as assertions — statements that should always hold true. There are three types of assertions: pre-condition, post-condition, and invariants. Pre-conditions specify constraints that must be satisfied before invoking an operation. For example, for fltStatus operation, the parameter fltNumber must be a positive integer is a pre-condition. Likewise, for a division operation, the divisor should be a non-zero number is a pre-condition. A post-condition specifies what the object state should be after executing an operation. Suppose an operation performed the division \\(a = b \\div c\\), then \\(b=c \\times a\\) is a post-condition. Exceptions or error conditions are then the result of an operation for which one or more post-conditions are violated. An invariant is something that doesn’t change over the life cycle of an object. Assume CreditCard class, which has the attributes: beginningBalance, endingBalance, creditsAndPayments, purchasesAndCashAdvances. The expression endingBalance = beginningBalance + purchasesAndCashAdvances - creditsAndPayments is an invariant. This is a typical formula used for reconciling credit card accounts. Relevant post- and pre-conditions, and invariants should be associated with all public operations. 2.3.6 Messages Regardless of how powerful a class functionally is, it has limited use in isolation. A typical software application will have several classes. A class may fulfill its responsibilities by invoking its own methods, invoking the methods of other classes, or a combination of both. The act of a class/object invoking the method of another class is referred to as sending a message. In other words, messages are the communication mechanism for objects to invoke each other’s methods in cooperatively solving a problem. The object which sends the message is called the sender, and the object that receives the message is called the receiver. A message has three parts: receiving object name, a method name in the receiving object, and parameter values for the method invocation. Parameters are used to pass values from one object to another. As discussed earlier, the method signature specifies the direction, name, return type, parameters and default value (if any) for the parameters. For example, to assign 123456789 as social security number for an object whose identifier is jim:Passenger, the message syntax is: jim:Passenger.setSSN (123456789). Here jim:Passenger is the receiving object, setSSN is the method name in the receiving object, and 123456789 is the parameter value. Period \\((\\cdot)\\) is used to separate the receiving object name from its method name. Every public method of a class has an associated message. Message syntax varies from one OO programming language to another. Processing a message involves insuring that the message conforms to the method signature and then executing the associated method body. The value returned to the sender object depends on the return value type of the method. It can be as simple as an elementary data type such as an integer, an instance of a class, or even a collection of instances from the same or different classes, or none. Messages can be sent in synchronous or asynchronous mode. In the synchronous mode, the message sender doesn’t perform any action until the receiving object has executed the method corresponding to the message. In contrast, in asynchronous mode, the sender initiates the message and continues to perform some other action. When the method execution is completed by the receiver, the sender is notified. Which mode is suitable for sending a message is dependent on the problem context. Asynchronous mode helps in making programs more responsive, but also requires additional logic to recognize message completion. 2.3.7 Relationships Typically, classes don’t stand in isolation. They are related to each other via: association, aggregation, composition, and generalization/specialization. 2.3.7.1 Association Association is a type of relationship between (instances of) classes. There can be multiple associations between the same set of classes. The classes play different roles in each association. For example, if Girl and Boy are two classes, an association named oppositeGenderClassmate relates boys (i.e., instances of Boy class) with girls (i.e., the instances of Girl class) who are classmates. Another association named oppositeGenderFriend between the same two classes relates boys and girls who are friends. Typically cardinality (or multiplicity) as well as optionality are specified for associations. Cardinality factor specifies how many instances of Girl class can be associated with an instance of Boy class; conversely, how many instances of Boy class can be associated with an instance of Girl class. Optionality factor specifies whether or not instances can exist without participating in any association. For example, can a girl exist without being participating in either of the associations? The following example further illustrates cardinality and optionality aspects of an association. People who have money to invest may seek the services of a professional. Such professionals are called investment managers. In this context, people who are investing money are referred to as clients. Figure 2.3 shows different types of association between the instances of Investment Manager and Client classes. We use uppercase, singular nouns for class names. In Figure 2.3(a), there are three instances of Investment Manager class (Windfall Joe, Flashy John, and Miracle Sue) and three instances of Client class (Ordinary Joe, Average Smith, and Millionaire Bob). In Figure 2.3(b) – Figure 2.3(d), there is one more instance of Client class (Billionaire Janet). Figure 2.3: Cadinality and Optionality aspects of association Figure 2.3(a) depicts a one-to-one association between the instances of Investment Manager and Client classes. For example, the line connecting Windfall Joe and Millionaire Bob represents an association: Windfall Joe is an investment manager of Millionaire Bob (or, equivalently, Millionaire Bob’s investment manager is Windfall Joe). Notice that any instance of Investment Manager class is associated with one and only one instance of Client class and vice versa. Furthermore, no instances of either class can exist without participating in the association — mandatory participation. Figure 2.3(b) represents a one-to-many association with mandatory participation for the instances of both classes. An instance of Investment Manager is associated with one or more instances of Client — Miracle Sue has two clients: Average Smith and Billionaire Janet. However, an instance of Client is associated with one and only one instance of Investment Manager. Instances of neither class can exist without participating in the association. In a one-to-many association, it is important that we make the distinction between the class on the one&quot; side and the class on the many side. In other words, you need to recognize the direction of the association in a one-to-many association. Figure 2.3(c) represents a many-to-many association with mandatory participation. An instance of Investment Manager is associated with one or more instances of Client and vice versa. For example, Average Smith’s investment managers are: Windfall Joe and Miracle Sue; Windfall Joe’s clients are: Average Smith and Millionaire Bob. Thus the association plays a different role in each direction — has investment mangers and has clients. Instances of neither class can exist without participating in the association. Figure 2.3(d) represents a one-to-one association with optional participation. An instance of Investment Manager is associated with one and only one instance of Client and vice versa. Instances of either class can exist without participating in the association — Miracle Sue has no clients and Billionaire Janet has no investment manager. It shouldn’t be difficult for you to visualize optional participation with one-to-many and many-to-many associations. Dependency is a type of association between two classes indicating dependency of one class on another class. For instance, in a personnel application of a company, there exists a dependency relationship from Child class to Employee class as shown in Figure 2.4. Conceptually, Child class has no independent existence (or its existence is tied to the existence of Employee) — no company keeps track of children information without the corresponding employee information. From a specification (or implementation) view point, if a class \\(A\\) uses another class \\(B\\) in its method signature, there is a dependency association from \\(A\\) to \\(B\\). In Figure 2.4 example, Child class will typically use Employee in one of its method signature. Any changes made to Employee class will affect the Child class. Figure 2.4: Dependency association between classes An association between two classes is called binary, between three classes it is called ternary, and between \\(n\\) classes it is termed \\(n\\)-ary. An association between instances of the same class is referred to as recursive association. Often the terms association and relationship are used synonymously. 2.3.7.2 Aggregation and Composition Classes in general have independent existence (except those related to other classes via dependency as discussed above) and render services by executing messages sent to them. In this sense, they are autonomous. Sometimes there is a need to bring two or more classes together to work under a protocol which may diminish the autonomy of some classes. This gives raise to a concept known as aggregation, which is a special kind of association. One class represents a larger thing (or container class) and others constitute smaller things (or contained classes). For example, if we think of a Home as a container class, contained classes include Dish Washer, Dryer, Water Heater, and Room, among others. Though the contained classes are themselves useful in isolation, their utility is enhanced in the aggregation scenario. Practical applications such as airlines reservation and air traffic control systems contain hundreds or even thousands of classes. Developing or enhancing such applications requires mastery of these classes from a functional perspective. Aggregation provides an effective mechanism for building higher-level abstractions by encapsulating the functionality of several contained classes. Typically these higher-level abstractions are akin to domain tasks thus making them natural and easier to use. This also promotes reuse — ability to use these domain-level container classes in other applications. In other cases, aggregation simply provides an integrated and consolidated functionality — instead of learning the functionality of several classes, you learn the functionality of just one class (i.e., the container class). This alternative lays the foundation for a mechanism called delegation, in which the container object delegates work to the contained objects. There are two variations of aggregation depending on whether or not the contained classes have independent existence from the container class. If the contained classes don’t have independent existence, the relationship is referred to as composite aggregation or simply composition. On the other hand, if contained classes have independent existence, the relationship is referred to as shared aggregation or simply aggregation. To avoid confusion, we consistently use the terms composition and aggregation to refer to composite aggregation and shared aggregation. In composition, the container class owns the contained class. Consider the following classes in a university setting: Course and Section. The class Section doesn’t exist without the Course. Therefore, the relationship between Course and Section is composition (i.e., Course has or owns Section). Another example is the relationship between a book and its constituent chapters. Chapters have no independent existence without the book. In aggregation, classes are brought together to form larger and more complex classes; yet the participating classes retain their individuality. There is no existential dependency between the classes participating in the aggregation. In other words, parts can exist without the whole. Consider the classes Man and Woman and an aggregation called Marriage. An instance of Marriage class consists of an instance of Man and an instance of Woman. However, instances of Man and Woman classes have independent existence outside of Marriage aggregation. Instances of Man and Woman classes can continue to exist even after ceasing their participation in Marriage. 2.3.7.3 Generalization/Specialization Inheritance is a core aspect of OO techniques. Through inheritance mechanism, more specialized classes are produced from an existing class. The latter is referred to as the base class, parent class, or superclass and the former is known as the derived class, child class, or subclass. If we use the term type for class, the derived class is called subtype. Let us confine to the terms base class and derived class in our discussion. Specialization can be carried to multiple levels. However, the need for more than three levels needs to be questioned in practice. The resulting structure is known as class hierarchy. At the top of this hierarchy is the root class from which all other classes are derived either directly or indirectly. For example, in the .NET Framework Class Library (FCL), all classes are derived from Object class including the ones that you develop (which are implicitly derived). The classes from which no classes are derived are called leaf classes. Consider the two class diagrams shown in Figure 2.5. The first one (Figure 2.5(a)) is rooted at Person class. Client and InvMgr classes are derived from the Person class. Both clients and investment managers are people and this commonality in structure and behavior is captured in the Person class. The structure and behavior which is specific to clients and investment managers are captured in Client and InvMgr classes, which are also leaf classes. The other hierarchy (Figure 2.5(b)) is rooted at FinInstr class, from which two specialized classes Stock and Bond are derived. The Bond class is further specialized into: CorpBond, MuniBond, and GovtBond. They correspond to corporate, municipal, and government bonds. Stock, CorpBond, MuniBond, and GovtBond are all leaf classes. Note that the graphical symbol \\(\\uparrow\\) from the derived class to the base class to denote generalization/specialization relationship — the base class is a generalization of the derived class; conversely, the derived class is a specialization of the base class. Figure 2.5: Two Class hierarchies A class hierarchy is a manifestation of the generalization/specialization principle. Just as classes are viewed from three different perspectives, the generalization/specialization hierarchy can also be interpreted from those three perspectives. From a conceptual view point, class \\(B\\) is a derived class of \\(A\\) if all instances of \\(B\\) are also instances of \\(A\\). Everything that holds true in the context of \\(A\\) also holds true for \\(B\\). From a specification perspective, interface of \\(B\\) must include all interface elements of \\(A\\). That is, interface \\(B\\) conforms to interface \\(A\\). Finally, from an implementation perspective, class \\(B\\) inherits all the fields and methods of class \\(A\\). As we traverse down the class hierarchy, classes become more and more specialized. Likewise, as we go up from the leaf classes towards the root class, they become more and more generalized. When designing class hierarchies, you can start with a set of leaf classes and create a base class that abstracts structure and behavior shared by all the leaf classes. The base classes resulting from generalizing different sets of leaf classes can be further generalized to create the next higher level base classes and so on. Alternatively, you can start with the most general class (i.e., the root class), and look for variations to create specialized classes. The common structure and behavior is retained in the root class and the variations are pushed down into the derived classes. This is repeated to the desired number of levels provided we can find variations on the structure and behavior of the class under consideration. The derived class inherits both the structure and behavior of the base class. Also, the derived class can add additional structure and behavior to the inherited ones. Furthermore, the derived class can override the inherited behavior by reimplementing the corresponding methods. This redefinition of a method locally is needed to address exceptions or special cases addressed by the derived class. Therefore, an operation can be implemented by multiple methods, each method implementation differs to suit the local context of classes in the hierarchy. There are two types of inheritance: single and multiple. Under single inheritance, a derived class is based on only one base class. Under multiple inheritance, a derived class is based on multiple base classes. C# programming language doesn’t provide multiple inheritance feature since there are certain problems associated with multiple inheritance. More specifically, the semantics of multiple inheritance are not clearly defined in the general case. What happens when both base classes feature the same method? From which base class is the method inherited? Worse yet, what happens when base classes conflict in their definition of the same method? When we consider a class hierarchy from a conceptual or specification perspective, inheritance is referred to as interface inheritance. This is because what is inherited by the derived class is the specification of the operations. Interface inheritance is supported in C# using interfaces. On the other hand, when a class hierarchy is viewed from an implementation perspective, the inheritance is referred to as implementation inheritance. The derived class inherits implementation aspects from the base class. 2.3.8 Polymorphism In OO programming, the term polymorphism refers to the ability of the language to process objects differently based on their data type or class, yet treating them equivalently within the program. This feature is best explained using an example. Consider the class hierarchy rooted at FinInstr class in Figure 2.5(b). Typically instances of this class are not created. The class exists solely for organizational purpose. It generalizes fields and methods that are common to all its derived classes. Such classes have one or more methods designated as polymorphic or virtual methods — those that can be reimplemented by the derived classes (if they choose to) keeping the method signature intact. Assume that there is a method called valueFinInstr defined in FinInstr class as a virtual method. Then the derived classes Stock and Bond may choose to reimplement this method under the same name but in a way that reflects the semantics of Stock and Bond classes. The derived classes of Bond — CorpBond, MuniBond, and GovtBond — can also reimplement the valueFinInstr method. Polymorphism feature allows the derived classes to reimplement the valueFinInstr method in a way that reflects the desired semantics of the class. This is important since the way stocks are valued is quite different from the way the bonds are valued. Furthermore, corporate bonds are valued differently from those of the municipal and government bonds. Polymorphism enables you to treat corporate bonds, municipal bonds, and government bonds as instances of the Bond class (substitution principle) and process them in a uniform way. For example, invoking the valueFinInstr method in Bond class will value each bond correctly. If an instance is of type corporate bond, the language runtime will execute the valueFinInstr method implemented in the CorpBond class to value the instance; if the instance is of type municipal bond, valueFinInstr method implemented in the MuniBond class is executed; and so on. The same mechanism will work on any new derived classes of Bond class (e.g., agency bond) which we may create in future; all this without changing any part of the source code used for valuing the bonds. For this to work, it should be possible to substitute derived class instances for the base class instance. This is known as substitution principle. The primary benefits of inheritance are: abstraction manifested in the class hierarchy, code reuse (derived classes get the base class’s methods implementation for free), and facilitating polymorphic behavior (simplifies code development and minimizes code changes). In passing it should be noted that for reasons which are discussed in Chapter ??, inheritance should be used with caution and in moderation. Composition should be explored as an alternative to inheritance. Invariants and post-conditions should be satisfied by all the derived classes. The derived classes may strengthen these assertions, but weakening them is prohibited. On the other hand, pre-conditions cannot be strengthened but may be weakened by the derived classes; otherwise, the polymorphism feature will fail. 2.3.9 Interfaces An interface is an abstract specification of software functionality in the form of services or operations. It is specified without implementation related considerations. In other words, its specification is free from operating system and programming language related issues. Typically one or more classes implement an interface. Conversely, a class may implement multiple interfaces. Multiple inheritance is achieved by having a class implement two or more interfaces. We need to revisit the message structure to appreciate the need for interfaces. A message has three parts: receiving object name, a method name in the receiving object, and parameters. Note that message parameter types must match the corresponding types in the method signature that implements the message. Parameter types can be basic data types such as integer, or a class type. When objects are passed as parameters, they are checked against their class or interface. The language runtime will insure that the corresponding parameter type in the message is of that class or any of that class’s descendants (substitutability principle). Since the derived classes are required to implement the message interface of the base class, the derived class and the base class are functionally equivalent. Therefore, a base class can be used to specify an entire subtree of classes under it for a method parameter (including those which may be defined under the base class in future). Though this provides ample flexibility, experience with large scale systems has shown its limitations. Any object which is not an instance of a derived class of the base class will not qualify as valid parameter type in the message. However, in real-world applications there will be multiple class hierarchies. To enable classes that are not necessarily within the same class hierarchy to match a method parameter type, interfaces are used instead of classes for method parameter types. Any object of a class which implements the interface can be used as a method parameter. In effect, this eliminates the single hierarchy restriction by capturing similarities among unrelated classes without artificially forcing a base class/derived class relationship. Interfaces have other advantages as well. Opportunities for interface reuse exist since they are specified independent of any class. A class can choose to implement a number of interfaces that are relevant to fulfill its responsibilities. Interface based segmenting or partitioning of the methods of a class provides benefits. Each partition corresponds to an interface. It helps to promote information hiding. The user of a class is exposed only the interface that features messages of interest to the user. The same feature also contributes to security. The user of a class is provided access to just the needed messages; no more and no less. An object’s programming interface is revealed without revealing its class. Security master is a core application found in financial services industry. It provides descriptive and pricing information on various securities or financial instruments. The universe of instruments is large and exceeds five million. About 800 attributes are required to completely describe an instrument. However, a given application requires only a small subset of attributes. Figure 2.6 shows a composite interface found in a security master application. The four interfaces are designed to meet the needs of four different applications: corporate action processing, stock record, global custody, and trading. The users of stock record application, for example, are exposed to only the stock record interface. In other words, they are not required to understand the entire security master class. Figure 2.6: Composite security master interface 2.4 Unified modeling Languages Unified Modeling Language (UML) is an industry standard language for specifying, constructing, visualizing, and documenting software-intensive systems. It is standardized by the Object Management Group (OMG). Its genesis lies in the confluence of several OO analysis and design techniques, and other system development methodologies. Primary intent of UML is to help effectively communicate system requirements, specifications, design decisions, and various design artifacts including system structure and behavior, and architecture. It also helps to minimize project risk, and expose opportunities for simplifying the system design and construction. It is only a modeling language and doesn’t prescribe a process. A process details what steps to be taken in performing software analysis, design, and construction. UML has been shown useful in a software process which is use-case driven, architecture-centric, and is iterative and incremental. There are two processes that have gained recognition: Rational Unified Process (RUP) and Enterprise Unified Process (EUP). UML provides nine different types of diagrams: use case, class, object, component, deployment, sequence, collaboration, state, and activity. Some of these depict the static aspects of a system whereas, others model the dynamic aspects. Not all diagrams are needed for every software system. We briefly describe the diagrams in the following. You should focus on gaining a conceptual understanding of the diagrams, rather than worrying about the nitty-gritty details. Mastery comes with hands-on practice. Certain diagrams (component and deployment) are not discussed in detail and are included only to make the brief introduction to the UML complete. 2.4.1 Use Cases and Use Case Diagrams Use cases specify what a system does without saying anything about how it is done. In other words, it captures the system behavior without addressing how the behavior is implemented. It is important that the problem analysis phase be carried out without undue influence of the implementation concerns. A use case is specified by describing flow of events in text clearly enough for others to understand easily. The description should include: how and when a use case starts and ends; pre- and post-conditions, and invariants; when it interacts with actors; what objects are exchanged; and basic and alternative flows of behavior. Actor represents a set of roles that users of use cases play when interacting with the system. Actors can be human users or other systems. Each flow corresponds to a scenario and a use case actually represents several scenarios (corresponding to the main and alternative flows). A scenario is an instance of a use case just as an object is an instance of a class. Just like classes, a use case can generalize another use case, and can be included in other use cases. A use case can also extend another use case. Use case scenarios are best illustrated using an actor’s interaction with an automated teller machine (ATM) for cash withdrawal. A normal scenario corresponds to: user inserts the ATM card and enters a valid pin followed by withdrawal amount correctly; the withdrawal amount is less than the current account balance, and the cash in the ATM machine is equal to more than the withdrawal amount; and the machine’s cash dispensing mechanism is working. This is a best case scenario in that every step ran smoothly without any glitches. However, lot of things can go wrong: user enters an invalid pin; withdrawal amount is greater than the current account balance; cash on the ATM machine is less than the withdrawal amount; and the machine’s cash dispensing mechanism is dysfunctional. Think of withdrawing cash from the ATM as a user task, whose execution is carried out by performing a number of mini-tasks. The execution of each mini-task may be successful or unsuccessful. The task is complete only if all of the mini-tasks are executed successfully. This corresponds to the normal or main scenario (or flow). There are several other scenarios in which some steps are executed successfully and other steps have failed. An alternative scenario (or an alternative flow) corresponds to some such combination of steps. A use case is a set of scenarios corresponding to realizing a user task or goal. The best case scenario is the main flow and others are alternative flows (or alternative scenarios). Both the main and alternative flows correspond to the successful execution of a user task. Exceptional flows correspond to execution scenarios resulting in error conditions. In general, it may not be necessary to execute all the mini-steps; they may even be executed conditionally. Use cases are related to each other via include, generalization, and extend relationships. Certain tasks (such as validating an ATM card in banking applications) are abstracted to form a use case. Such use cases are meant for inclusion in other use cases; by themselves they are of no value. For example, if ValidateCard is a use case for validating ATM cards in a banking application, it can be used in other use cases such as cash withdrawal, and transferring money between accounts. Cash withdrawal use case is said to include ValidateCard use case. A use case may generalize/specialize other use cases to accommodate variations or specialization. In such cases, they are related by the generalization relationship. Finally, an use case may extend another use case. Extend relationship is similar to the generalization, but there are additional rules governing the extension. The use case that is being extended (called base use case) should have already defined extension points. The extending use case extends one or more of the extension points in the base use case. In the investment management (IM) application discussed in Section ??, computing unrealized gain/loss is a use case. Computing market unrealized gain/loss is another use case which extends the unrealized gain/loss use case. Likewise, computing currency unrealized gain/loss for multi-currency accounts is another use case which extends unrealized gain/loss. A use case labelled Create Account for creating an account is shown in Figure 2.7. Actor is an investment manager. Use cases are denoted by solid ovals (with the use case name written inside the oval) and actors are represented by stick figures. Figure 2.7 depicts the interaction between the use case Create Account and the actor Investment Manager. Such diagrams are known as use case diagrams. An actor may interact with multiple use cases, and a use case may have multiple actors. An actor interacting with multiple use cases is shown in Figure ??. Figure 2.7: A use case diagram Use case diagrams are central to modeling the context of a system, subsystem, or even a class. Context depicts the boundary of an element and its interaction with the outside world. They are used to visualize the behavior of a system, subsystem, or class. Use case diagrams depict static use case view of a system. They help developers of the system to get a conceptual understanding of how these elements interact with each other so that they can implement them. There are two basic complementary approaches to discovering the use cases: actor-based and event-based. Relatively, it is easier to start with the actor-based approach. As stated earlier, an actor corresponds to a human user or other systems. An actor may play multiple roles. For example, a senior investment manager may manage other investment mangers as well as manage client accounts. By examining each role, you can come up with a set of use cases. They correspond to the domain tasks that users perform regularly. In the event-based approach, use cases are discovered by carefully examining the events that occur in the system. For example, period-end is an event. It may correspond to end of business day; end of calendar month, quarter, and year; end of fiscal quarter, and year. In banking applications, period-end activities include computing trial balance, reconciling account balances, and generating monthly statements, and mailing calendar year tax statements. Use cases typically correspond to these types of activities. Use cases for the IM application are discussed in Section ??. Use cases have other uses as well. They form the basis for developing test cases. Use cases applied to a subsystem are an excellent source for regression testing. When applied to an entire system, use cases are a good source for designing integration and system tests. Eventually use cases need to be implemented or realized. Classes and other elements are modeled as a collaboration to realize a use case. Collaboration diagrams are discussed in Section 2.4.4. 2.4.2 Class Diagrams Class diagrams show important abstractions present in the system. They convey static design view of a system. As discussed in Section 2.3, classes have structure and behavior, participate in relationships with other classes (generalization/specialization, association, aggregation, and dependency), and implement interfaces. A class diagram captures all these semantics. We have already seen in Figure 2.5 two simple class diagrams. Figure ?? shows the class diagram for the Investment Management application. Class diagrams should reflect domain concepts and the vocabulary of the users. Therefore, the initial class diagrams must be developed from a conceptual perspective. 2.4.3 Object Diagrams Object diagrams model instances of elements contained in a class diagram. They show a set of objects and their relationships at a point of time. They express static part of interaction among objects without any messages passed among them. Object diagram is simply a graph of nodes and links. Nodes correspond to specific objects and links denote static interactions among the objects. Object diagrams help in visualizing a snapshot of a complex interaction involving specific objects. Object diagrams are also called instance diagrams. 2.4.4 Sequence and Collaboration Diagrams equence and collaboration diagrams are used to depict dynamic aspects of an OO system and are called interaction diagrams. They depict interaction among a set of objects including message passing. Typically, they capture the behavior of a single use case.Sequence diagrams emphasize the time ordering of messages. They are used to illustrate the chain of messages generated and executed (in time sequence order) in response to a domain task. Hence, they convey dynamic view of a system by depicting the overall flow of control. We illustrate a sequence diagram for a telesales application. You as a customer call a telesales operator and place an order for items of interest. For each item you want to purchase, you provide the operator item name (or an identifier such as product number) and quantity. In essence your order consists of one or more line items — a line item corresponds to each product you have ordered. Through a GUI, the operator submits the order to the system. Figure 2.8 depicts a sequence diagram for processing such orders. Figure 2.8: A sequence diagram The diagram has four objects: :Order, :Catalogue, :Tax, and :Shipping. The :Order object has overall responsibility for processing an order. The :Catalogue object maintains complete product information (e.g., name, description, identifiers such as Universal Product Code (UPC), price, discount schedule based on volume, availability — in stock or not, status if back-ordered). :Tax object specializes in computing applicable taxes for a line item. You should recognize that, in reality, computing tax is not just multiplying total cost of products ordered with sales tax rate — requires consideration of tax exempt status based on customer type, geographic location, among others. Finally, :Shipping object specializes in computing shipping costs by considering parameters such as warehouse geographic location, shipping address zip code, mode of shipment (e.g., air, ground, sea), urgency (e.g., overnight, two-day, normal), type and amount of insurance desired to protect against transit damage. Each object is represented by its lifeline — object lifeline. As shown in Figure 2.8, the object name is written inside a rectangle and the lifeline is the dotted line going downwards from the rectangle. An object’s lifeline indicates the time interval of its existence at a particular time. However, it may not be performing actions during this entire time interval. The time interval during which an object is performing an action is indicated by activation (or focus of control), which is indicated by placing a rectangle on an object’s lifeline. Notice in the figure that :Order object has a longer activation relative to the other objects. An arrow represents a message between two objects. The arrow is labeled with message name, control (e.g., conditional, iteration marker), and other information (e.g., method parameters). For example, the arrow from :Order to :Catalogue represents the :Order object invoking inquire method of the :Catalogue object. The value returned by this message is indicated by onHand — whether or not the item inquired is in inventory. The symbol \\(\\ast\\) before onHand represents repetition — send the message for each line item in the order. Message return is indicated by a dotted arrow as shown in the figure from :Catalogue to :Order. Typically message returns are not shown as they tend to clutter the diagram. They are understood implicitly. They should be included only if they contribute clarity to the diagram in some way. Time ordering of messages is implicitly indicated by the order of their physical placement across the object lifelines. Time dimension increases as we go downwards from the rectangles. The message call from :Order to :Tax illustrates another feature of sequence diagrams — conditional method call. It denotes that tax for a line item should be computed only if the item is in the inventory. Conditional message is indicated by prefixing the condition (which is enclosed in [ and ]) to the message as in [onHand] tax(). Another feature shown in the diagram is self-call — an object sending a message to itself. The :Order object does a self-call by invoking its own method: backOrder(). This method takes care of back-ordering those items that are not in the inventory. As you might have understood by now, sequence diagrams are good for time-ordered depiction of message passing among a group of objects. This is very helpful to figure out which methods are invoked by what classes and in which order. If a method doesn’t appear in any sequence diagram, it must then be an utility method. Otherwise, the method simply exists without any purpose. Collaboration diagrams emphasize the structural organization of objects that communicate using messages. They are useful in showing how objects collaborate in realizing a domain task (e.g., a use case). Objects are shown as icons. Message ordering is indicated by numbering the messages. Figure 2.9 shows the collaboration diagram corresponding to the sequence diagram of Figure 2.8. In contrast with sequence diagrams, time ordering of messages is explicit in collaboration diagrams — decimal numbers prefixed to message labels indicate message ordering. Sequence and collaboration diagrams are semantically equivalent meaning that one can be derived from the other. As you can see from Figures 2.8 and 2.9 that one can be constructed from the other. Figure 2.9: A collaboration diagram 2.4.5 State Diagrams Like interaction diagrams, state diagrams illustrate the dynamic view of a system. They are central to modeling the behavior of an interface, class, or collaboration. They emphasize event-driven behavior of an on object. You use a state diagram to depict the behavior of an object over its lifetime. An object’s lifetime may span across multiple use cases. State diagram is a state machine consisting of a set of states, transitions, events, and actions. One of the states is designated as the start state and the machine contains one or more terminal states. Each state may be associated with one or more actions. When control moves into a state upon the occurrence of a designated event, the corresponding action is executed. State transitions are triggered by events. State diagrams can be attached to classes and other elements to show their dynamic behavior. Interaction dynamics found in vending and ATM machines are modeled very effectively using state machines. Figure 2.10 depicts a highly simplified version of a state machine for train tickets vending machine. The start state is designated by Black Dot. It has only one end state, which is designated by black dot with circle on it. In addition, it has five other states: WaitForOriginationStation, WaitForDestinationStation, WaitForCreditCardAuthorization, WaitForCashPayment, and IssueTicket. When the state machine starts, it enters into WaitForOriginationStation state. The user is prompted to choose a origination station (station/stop at which the journey begins). The machine will continue to remain in this state until the user has successfully selected origination station. The latter constitutes an event and the machine transitions to WaitForDestinationStation. In this state, the user enters a destination station (station/stop at which the journey ends). Successful entry of this information triggers an event and the machine moves into WaitForCreditCardAuthorization or WaitForCashPayment. Which one of these two states is entered is based on the user’s response to method of payment decision. The latter is modeled by fork, shown below the WaitForDestinationStation state. A fork has one input and two or more outputs. In our example, outputs correspond to the number of choices the user has for ticket payment: credit card or cash. Once the payment is received by one of these methods, the state machine enters IssueTicket state via a join. The latter is shown just above the IssueTicket state. Its function is just the opposite of fork: merges multiple inputs into one output. Once the ticket is issued, the machine enters the end state. Figure 2.10: Statechart diagram of train ticket vending machine You are reminded that state machine in Figure 2.10 is a highly simplified one. In reality, it will have several additional states and transitions. We haven’t addressed several issues including: what happens when you want to change either the origination or destination station? What if the credit card authorization fails? What if you insert more cash than than the ticket price? Does the machine allow you to terminate your session without buying a ticket? 2.4.6 Activity Diagrams Activity diagrams are used to model dynamic aspects of a system, especially in describing workflow and behavior that is characterized by parallelism. They depict sequencing of activities with provision for both conditional and parallel behavior. Just as sequence diagrams model flow of control from one object to another, activity diagrams model flow of control from one activity to another. Figure 2.11 is an example of an activity diagram. It describes the sequence in which the chapters in a hypothetical C# book should be read. There are three activities: Object Emphasis, Common, and Optional Topics. The vertical columns corresponding to these activities are referred to as swim lanes. Just like a state diagram, the activity diagram has states including a start state and an end state. There are several states for each activity. In other words, an activity transitions through several states as an activity is carried out. After you read Chapter 1, you can move on to either Chapter 2 or return to Chapter 2 after reading Chapters 17 and 18. Next you read Chapters 3, 4, and 5. Now you have reached a fork, which offers three parallel activities: Object Emphasis (Object-Oriented Analysis and Design, Classes, Inheritance and Polymorphism, and Interfaces chapters); Conventional Topics (Arrays, Strings, and Input and Output chapters); and Optional Topics (Windows Applications, Algorithmic Problem Solving, Basic Data Structures, and Advanced C# Constructs). There are dependencies within a parallel activity (e.g., you need to study Classes chapter before you can begin Class Inheritance and Polymorphism chapter). However, the chapters from different parallel activities can be sequenced in arbitrary ways. For example, after reading Object-Oriented Analysis and Design chapter you may read Arrays chapter and then return to Object Emphasis activity to read Classes chapter. The three parallel activities are merged using join construct as shown in the figure. The flow terminates at the end node. You can also include conditional branching in activity diagrams. Figure 2.11: An activity diagram 2.4.7 Component Diagrams Component diagrams are one of the two diagrams (other being deployment diagrams) for modeling physical aspects of OO systems. They illustrate static implementation view of a system. Component diagrams show organization and dependencies among a set of components. Components include executables, libraries, documents, database tables, initialization and configuration files. The scope of components is limited to those that exist on a node (a computer or a set of computers acting as integrated assembly). 2.4.8 Deployment Diagrams A deployment diagram complements component diagrams in modelling physical aspects of OO systems. It depicts static deployment view of a system architecture — configuration of runtime processing nodes and components that reside on them. It shows the nodes and networks, and dependency and other associations between the nodes. Deployment diagrams are also used to model embedded systems and distributed systems. 2.5 Investment Management Application Domain We introduce an application domain called Investment Management (IM) which will be used as a running example to demonstrate various aspects of OO problem solving. IM domain is chosen since its characteristics provide the necessary depth and breadth. However, the domain is simplified a great deal without sacrificing the salient characteristics in the interest of space and classroom time. The exposition of the domain is made easy and effective by making the reader play an investment manager role. 2.5.1 Application Domain Structure The IM application domain is characterized by: investment managers and clients, client accounts, account groups, financial instruments, instrument prices, issuers of financial instruments, client account transactions, account positions and lots, stocks and bonds, realized and unrealized gain/loss, acquisition and disposition schedules. In the following, they are described in some detail. 2.5.1.1 Investment Managers and Clients As an investment manager your principal job function is to manage client investments. Your specialty is in and are licensed to market two types of investments to clients: stocks and bonds. Furthermore, your expertise in bonds is limited to three kinds: corporate, municipal, and government. Stocks and bonds are investment vehicles and are referred to as financial instruments. Your license type determines what type of financial instruments you can include in your client accounts. You have plans to acquire an additional license to offer another type of financial instrument called derivatives to clients next year. Licenses are administered by state government agencies and a license is valid only in the state which issued it. Licenses have expiration dates. Since your business has grown tremendously in the last few years, you have employed several investment managers. You need an application to effectively manage your business and to provide on-line access and other services to your clients. There is a need to keep track of name, address, identifier, marital status (single or married) of both investment managers and clients. Identifiers uniquely identify investment mangers and clients. Identifiers can be of any type, for example, taxid, social security number. However, only one identifier is recorded for person. Additional information about clients such as client type (retail or institutional), annual household income, number of children, date of birth, and status (active, inactive, or suspended) is also maintained. 2.5.1.2 Accounts Clients have one or more accounts. Each account is managed by an investment manger. Account information includes unique identifier, name, type (401K, cash management, investment, IRA), investment objective (capital preservation, growth, income, growth and income), whether or not the account is margin enabled (yes/no), restrictions (e.g., account should not hold investments related to alcohol and tobacco), lot option indicator (explained later, assumes yes/no values), lot disposition method (first in first out (FIFO), last in first out (LIFO), high cost, low cost, average cost), open date, close date, status (active, inactive, suspended), and service level (platinum, gold, silver, nominal). Margin enabled accounts can purchase new financial instruments by pledging the existing instruments in the account as collateral. 2.5.1.3 Accounts Groups Accounts are grouped to form account groups. Grouping is based on various criteria such as investment objective, and account restrictions. Primary purpose of grouping is to control exposure, diversification, and other risk management strategies at the group level instead of at the account level. Information for this purpose include group unique identifier, name, description, purpose, start and end dates. Investment managers create and manage account groups. 2.5.1.4 Financial Instruments Anything that can be owned by an account as an investment is a financial instrument. Stocks and bonds are two examples. Cash is also treated as one type of instrument. Information about instruments include name (e.g., Cisco Systems common stock), identifier type (ticker symbol, CUSIP, ISIN), identifier value, description, issue date (i.e., when came into market), unit size (e.g. stocks are sold in units of 1, and bonds in units of 10), unit of measure (how the instrument is measured, e.g., stocks, bonds, options, gallons, bushels), denominated currency code (ISO currency codes for US Dollars, Indian Rupees, etc.), trading activity status (active, inactive, suspended), rating value (strong buy, buy, hold, sell), name of the institution which assigned the rating, date of rating, price quote method (percentage or yield for bonds, monetary value for stocks), and price multiplier (e.g., for stocks it is 1, and is 0.01 for bonds) 2.5.1.5 Prices In order to value accounts, you need to keep track of current prices of instruments as well as price history. This allows you to compute account value for a past date. Information about price includes unique identifier, unit price, price source (JJ Kenny, Bloomberg, ILX, Reuters, Telekurs), date and time, price type (open, close, low, high), price quote method, and price multiplier. 2.5.1.6 Issuers Financial instruments are issued by private corporations, government and its agencies, and municipalities. These are called issuers of financial instruments. Information about issuers includes name (e.g., IBM Corporation), description, type (corporation, government, municipality), state of domicile, address, and rating value, source, and date. Issuers are rated by institutions such as S&amp;P and Moody’s. The rating is intended to reflect the issuer’s credit worthiness. The rating is an important criteria in bond trading. 2.5.1.7 Transactions An investment manager buys and sells (i.e., trades) financial instruments for his client accounts. These types of actions against an account are called transactions. Specification of a transaction encompasses unique trasaction identifier, transaction date and time, account for which the transaction is made, transaction type (buy, sell, add cash, withdraw cash), financial instrument traded (instrument identifier type and identifier value) and quantity, and which manager initiated the transaction. We assume that all transactions get executed correctly and immediately. Buy and sell transactions affect positions and lots. 2.5.1.8 Positions and Lots Each instrument owned by an account corresponds to a position. Thus, an account can have multiple positions. Position is a cumulative quantity, which grows and shrinks as quantities of an instrument are acquired or disposed. Positions of an account comprise the account’s portfolio. Position information includes unique position identifier, cumulative quantity, cost basis (how much did the position cost), cost basis method (what method is used to compute the cost basis of the position), encumbrance indicator (yes/no), and encumbrance reason. Encumbrance is any type of restriction on the position which is used to prevent the position from being disposed. The position doesn’t say anything about its acquisition history — how much quantity was acquired on what date. The acquisition history has implications for capital gains tax which comes into play when a position is disposed (partially or in full). Lot is a mechanism for keeping track of position history. Whether or not to maintain lots for an account is an account level option. If lot option is chosen, every position owned by the account has one or more lots. Information about a lot includes unique lot identifier, lot number (a monotonically increasing integer number starting at 1), acquisition date, acquisition code (how a lot was acquired (e.g., purchase, result of a distribution), and cost basis (how much did the lot cost including commissions and fees). 2.5.1.9 Stocks Your universe of instruments is confined to stocks and bonds (corporate, municipal, and government), which are two different types of financial instruments. There are two general categories of stock — common and preferred. Given the scope of our application domain, there is no need to delve further into this aspect. Information about a stock includes denominated currency code (which is an ISO currency code), stock type (common/preferred), and dividend indicator (whether or not the stock pays dividend). 2.5.1.10 BOnds Information about bonds include maturity date (date on which the principal will be returned by the issuer to the bond holder), coupon rate (interest rate the bond pays), coupon type (indicates whether or not the coupon rate is fixed), zero coupon indicator (yes/no; if yes, interest is paid in lump sum when the bond matures), and month and day on which the coupon/interest is paid. Additional information for corporate bonds includes whether the issuer of the bond has defaulted on payment, and if so, when. Additional information about a municipal bond includes purpose for which the bond was issued, collateral amount set aside by the issuer of the bond, collateral terms, how frequently collateral sufficiency is reviewed, when was the last time it was reviewed, and when is the next collateral review date. Note that collateral value changes with market conditions and hence it needs to be assessed periodically to assure liquidity of the bonds. Because of good faith in the government, government bonds need only one additional piece of information: bond status (current, on-the-run). 2.5.1.11 Realized and Unrealized Gain/Loss Before going into the details of application users and their roles, and functional aspects of the application, the following terms need explanation: realized gain/loss, unrealized gain/loss, acquisition schedule, and disposition schedule. Realized gain/loss for a sell transaction is the difference between the net proceeds from the sale of the instrument and its cost basis. Then realized gain/loss for an account is the sum of individual realized gain/losses of all the transactions related to the account during a time period. Time period can be year to date (YTD), quarter to date (QTD), month to date (MTD), or a specified date range. For example, in YTD all the sell transactions from the beginning of the current year through to date are included. Sometimes it is desired to calculate realized gain/loss only for transactions which involve financial instruments of certain type (e.g., stocks, municipal bonds), or a specific financial instrument (e.g., GE Common Stock). Unrealized gain/loss is similar to realized gain/loss except that we calculate it assuming that an account position in its enterity is sold at current market price. This is a what if scenario. Unrealized gain/loss for an account is the summation of unrealized gain/losses across all positions of an account. Sometimes it is desired to calculate unrealized gain/loss only for transactions which involve financial instruments of certain type (e.g., stocks, municipal bonds), or a specific financial instrument (e.g., GE Common Stock). 2.5.1.12 Acquisition and Disposition Schedule Acquisition schedule for an account is a listing of all buy transactions of the account over a time period (e.g., YTD, QTD, MTD, specified date range) sorted by date (most recent date first). Details shown include transaction identifier, date and time, instrument identifier type and value, instrument type, quantity, cost basis, unrealized gain/loss. Acquisition schedule can be filtered based on instrument type. Disposition schedule is similar to acquisition schedule except that it deals with sell transactions and excludes unrealized gain/loss but includes three additional pieces of information: sell date, net proceeds from the sale, and realized gain/loss. Disposition schedule can be filtered based on instrument type. 2.5.2 Application Users and Functionality Investment Managers (IMs) and clients are the users of the system. Investment managers create and maintain clients, accounts, and account groups. They also execute transactions for their client accounts. IMs with special privileges can create IM users, issuers, financial instruments and their prices. We enumerate IM functions with prefix IM and client functions with CL for cross referencing and requirements traceability purpose. 2.5.2.1 Investment Management Functions IM 1 Create an investment manager. Only IMs with appropriate privileges can execute this function. IM 2 Terminate an investment manager, change address and marital status. IM 3 Retrieve information about all IMs. IM 4 Create a client. IM 5 Change status, address, and marital status of a client. IM 6 Create an account, associate the account with a client and an investment manager. IM 7 Change account status and restrictions, investment manager, lot disposition method if applicable; enable and disable an account for margin. IM 8 Close an account. IM 9 List account summary for each of the accounts administered by an investment manager. IM 10 Create an account group. IM 11 Update account group information. IM 12 Associate and disassociate accounts with account groups. IM 13 Generate account group summary. IM 14 List all account groups administered by an investment manager. IM 15 Create a financial instrument. IM 16 Change an instrument’s activity status and rating. IM 17 Create a price for a financial instrument. IM 18 Update a price of a financial instrument. IM 19 Create an issuer. IM 20 Change an issuer’s rating. IM 21 Investment managers create and execute transactions for their client accounts. If it is a buy transaction, it should be possible for them to place an encumbrance. If the account maintains lots, encumbrance is placed on just the lot resulting from this transaction. If the account is not lotted and the account already has a position in the instrument that is being acquired, encumbrance is placed on the entire position. Otherwise, a new position is created and encumbrance is placed on the position. Investment managers need access to information related to financial instruments, their issuers and prices in creating and executing a transaction. IM 22 Retrieve portfolio for a specific account. IM 23 Retrieve portfolio for all accounts managed by an investment manager. IM 24 Retrieve portfolio of all accounts belonging to a specified account group of an investment manager. IM 25 Retrieve transactions for a specific account managed by an investment manager. It should be possible to make the retrieval more constrained by specifying transactions involving only certain instrument type (e.g., corporate bonds), a specific instrument (e.g., GE Common Stock), a date range (e.g., March 10, 2003 through April 10, 2004). Specific cases of data range include YTD, QTD, and MTD. IM 26 Retrieve transactions for all accounts managed by an investment manager. It should be possible to make the retrieval more constrained as in item IM 25 IM 27 Retrieve transactions for all accounts under a specified account group for an investment manager. It should be possible to make the retrieval more constrained as in item IM 25 IM 28 Compute realized gain/loss for a specific account managed by an investment manager. It should be possible to make realized gain/loss computation constrained to sell transactions involving only certain instrument type, a specific instrument, over a date range, YTD, QTD, and MTD. IM 29 Compute realized gain/loss for all accounts managed by an investment manager. It should be possible to make the computation of realized gain/loss more constrained as in item IM 28 IM 30 Compute realized gain/loss for all accounts under a specified account group for an investment manager. It should be possible to make the computation of realized gain/loss more constrained as in item IM 28. IM 31 Compute unrealized gain/loss for a specific account managed by an investment manager. It should be possible to make the computation of unrealized gain/loss more constrained by specifying buy transactions involving only certain instrument type, a specific instrument, over a date range, YTD, QTD, and MTD. IM 32 Compute unrealized gain/loss for all accounts managed by an investment manager. It should be possible to make the computation of unrealized gain/loss more constrained as in item IM 31. IM 33 Compute unrealized gain/loss for all accounts under a specified account group for an investment manager. It should be possible to make the computation of unrealized gain/loss more constrained as in item IM 31. IM 34 Produce month-end account statement for a specific account managed by an investment manager. The statement includes account information, details about the client who owns the account, investment manager information, account portfolio (including realized and unrealized gain/loss), and account transactions (buy, sell, add cash, withdraw cash). 2.5.2.2 Client User Function CL 1 View and change personal information: address, marital status, annual household income, number of children. CL 2 List account summary for all accounts of a client. CL 3 View portfolio. CL 4 View account transactions corresponding to one or more of client’s accounts. For additional details, see IM 25 and IM 26 above. CL 5 Compute realized gain/loss for transactions of a client account. It should be possible to make realized gain/loss computation constrained to sell transactions involving only certain instrument type (e.g., corporate bonds), a specific instrument (e.g., GE Common Stock), over a date range, YTD, QTD, and MTD. For additional details, see IM 28 and IM 29 above. CL 6 Compute unrealized gain/loss for a client account. It should be possible to make unrealized gain/loss computation constrained positions corresponding to certain instrument type (e.g., corporate bonds), and a specific instrument (e.g., GE Common Stock). For additional details, see IM 31 and IM 32 above. CL 7 Generate month-end account statement. Same as IM 34 above. 2.6 Investment Management Application In this section we explore and examine the completed investment management (IM) application. We have two objectives for this activity. The first one is to obtain a deeper understanding of the IM domain by interacting with the application in three different roles: administrator, investment manager, and client. The second goal (left to the reader) is to make an assessment of to what extent the requirements of the application informally described in Section ?? have been actually implemented. The IM application comes with three built-in login ids/passwords: admin/admin, jmaxwell/jmaxwell, and jhamilton/jhamilton. The admin login is a privileged one. This login id allows creating and viewing financial instruments and their prices, investment managers, and issuers of financial instruments. It also allows changing the password for the admin login id. The last two are login ids for investment managers John Maxwell and Janet Hamilton. Built into the application are 6 clients for John Maxwell and 4 clients for Janet Hamilton. Start the IM application by double-clicking on the corresponding executable file. The startup window of the application shown in Figure 2.12 appears. Only two items are active on the menu bar (Login and Exit) and others are disabled or grayed. Clicking on the login menu item pops up a login dialog box. Type in admin for both the username and the password. Successful login results in a window as shown in Figure 2.13. Notice that only Admin, Logout, and Exit are enabled on the menu bar. Figure 2.12: Startup window of IM application Figure 2.13: Login window of IM application Selecting the FinInstrument menu item from the Admin displays another dropdown menu with two items: Create and View. Selecting Create entails another dropdown menu with four menu items (Stock, Corp Bond, Govt Bond, and Muni Bond) as shown in Figure 2.14. Such menus are called cascading menus. If you select Stock, the window shown in Figure 2.15 is displayed for creating a financial instrument of type stock. Notice the various fields 4, of which some require typing a value in a textbox (e.g., Name and InstrumentID fields), whereas others require selecting a pre-defined value from a dropdown listbox (e.g., ID Type, Denominated Currency). The latter is a standard practice for those fields that can only admit values from a pre-determined set — an enumeration. The notation Admin \\(\\vert\\) FinInstrument \\(\\vert\\) Create \\(\\vert\\) Stock is used to refer to the sequence of menu selections: Admin followed by FinInstrument, Create, and Stock. For all the fields, specify values by typing in the textboxes or by selecting values for dropdown listboxes and click OK button to create a financial instrument. Verify that the instrument has been created by selecting the menu sequence: Admin \\(\\vert\\) FinInstrument \\(\\vert\\) View \\(\\vert\\) Stock. Figure 2.14: Admin functions menu Figure 2.15: Creating a financial instrument In practice, not all field values are required for creating an instrument. A distinction is made between required and optional fields. Required fields are indicated by color coding or by placing a special icon adjacent to the field’s textbox under the field name. You should now create and view investment managers, issuers, and prices of financial instruments. Verify their creation by choosing an appropriate menu sequence (e.g., Admin \\(\\vert\\) Issuer \\(\\vert\\) View for viewing issuers). Figure 2.16 shows the window for creating an investment manager. Figure 2.16: Creating an investment manager Exit from the application by clicking on Logout on the menu bar. Login again as an investment manager by using jmaxwell for username and password. IM functions are shown in Figure 2.17. They include creating, viewing, and updating clients (Figure 2.18), accounts, account groups; executing and viewing account transactions (Figure 2.19); computing realized and un-realized gain/loss (Figure 2.20; viewing client account summary, portfolio, and statements; and updating IM’s personal information. Figure 2.17: Investment manager functions Figure 2.18: Viewing and updating clients Figure 2.19: Viewing account transactions Figure 2.20: Viewing unrealized gain/loss We urge you to take time to familiarize with the IM application domain by deeply exploring the program. In Chapter AdvObjProbSolv we discuss OO analysis and design techniques. We then revisit the IM application domain and come up with a class diagram, and various relationships between the classes (generalization/specialization, dependency, associations, aggregation). We document our design artifacts using the relevant UML diagrams. We incrementally learn how the application has been implemented as we progress learning features of the C# programming language in the chapters ahead. 2.7 Chapter Summary Object-Oriented (OO) techniques offer means to analyzing, designing, and constructing software-intensive systems. Abstraction, information hiding, encapsulation, and polymorphism are the cornerstones of the OO approach. The first three are realized by the notions of interface, objects, and classes. Class hierarchy and inheritance features help realize the polymorphism feature. A class represents a collection of objects that have identical structural and behavioral characteristics. An object is created by instantiating the class. In other words, objects are class instances created by assigning values to the class fields. Objects and classes model the structure and behavior of entities of interest in the application domain naturally and effectively. Association and class hierarchy capture various types of semantic relationships between the classes. Method signatures (or message interface) of an object are essentially its interface to the outside world. Objects communicate with each other using messages. An abstract class is one which cannot be instantiated. They are created solely for organizational purposes — to specify common structure and behavior, which other classes can inherit from. Interface is another way to specify a collection of methods. Under this scenario, a class can implement one or more interfaces. Polymorphism feature enables subclasses (direct and indirect descendants) of a parent class be processed uniformly, yet allowing subclasses to exhibit their specialized behavior to suit the local context. Any of the subclass instances can be substituted for the parent class instance. Unified Modelling Language (UML) is an industry standard graphical language for visualizing, specifying, constructing, and deploying software-intensive systems. It has nine types of diagrams. They include use case diagrams, class diagrams, object diagrams, sequence diagrams, collaboration diagrams, statechart diagrams, activity diagrams, component diagrams, and deployment diagrams. Some of these diagrams depict the static aspects of a system, whereas the others model the dynamic aspects. Use case diagrams specify the system functionality in terms of how users interact with the system. Class diagrams reveal key abstractions present in the system. An object diagram indicates a snapshot of a complex interaction among a set of objects without any reference to the messages. A sequence diagram indicates time-ordered flow of messages between classes in solving a domain task. How various classes collaborate in solving a domain task is depicted by a collaboration diagram. Both sequence and collaboration diagrams reveal key behavioral abstractions of the system. They render message structures explicit and can reveal over centralized designs — designs in which all the application domain responsibilities are assigned to a few classes. A component diagram shows how various physical elements — executables, libraries, database tables, configuration and initialization files — relate to each other and exist on a computer. Finally, the deployment diagram shows the roadmap of a large system by depicting computers, networks, and their interdependencies. We introduced an application domain called Investment Management. This domain is used as a running example to illustrate the OO techniques and the C# language features. The reader is also introduced to a completed investment management application. 2.8 Exercises OO Terminology – Determine if each of the following statements is true or false: A class is a template for a group of objects with identical structure and behavior. A class encapsulates attributes and operations. A class is a runtime instance of an object. Objects have state, behavior, and identity. Objects communicate with each other via messages. A message is transmitted from attribute to attribute. Preconditions, post conditions, and invariants are assertions. Static methods can only access static fields. Instance methods can be invoked on a class. A derived class is a generalization of a base class. A static method is also called a class method. An abstract class can be instantiated. O Terminology – In Table 2.2, match each item on the left with an item on the right. Table 2.2: Exercise to test OO terminology Terminology Explanations Class Also Known as set method. Object Helps implement get and set methods. Modifier method Runtime instance of a class. Query Method Class-level field. Instance field Objects of the same kind.Objects of the same kind. Utility method Also known as a get method. Static field Field contained in each object instance. Instance method Bundling of related data and code. Superclass Derived class. Static method Method invocation requires an object instance. Subclass Showing relevant details while hiding irrelevant details. Encapsulation Ability of a single variable to reference a variety of different objects. Abstraction Method invoked on class itself. Polymorphism Parent class. Class Relationships – In Table 2.3, match each item on the left with an item on the right. Table 2.3: Exercise to test class relationship terminology Terminology Explanations Specialization An association between two classes. Aggregation A superclass is less specific than a sub class. Binary Association A class can have only one immediate superclass. Composition Inverse of Has-A relationship. Recursive association A class can inherit from multiple immediate classes. Generalization The contained class has no independence existence. Single Inheritance An association between instances of the same class. Multiple Inheritance A sub class is derived through this process. Part-of-relationship The contained class has independent existence. Unified Modeling Language – In Table 2.4, match each item on the left with an item on the right. Table 2.4: Exercise to UML terminology Terminology Explanations UML Represents a thing (living or otherwise) that interacts with a system in a specific way. Use Case An iterative software development process Actor A process independent language for visualizing; specifying; constructing and documenting the artifacts of a software-intensive system. Class Diagram Shows a set of objects and their relationships at a point in time. Also called instance diagrams. Sequence diagram State machine modeling the dynamic aspects of a system. Rational Unified Process Specifies what a system does without specifying implementation details. Collabration diagram Used to model the static design view of a system. Object diagram Emphasizes the time-ordering of messages. State diagram Illustrates the static implementation view of a system. Component diagram An interaction diagram that emphasizes the structural organization of objects communicating via messages. A class may represent software things, hardware things, and conceptual things. List some classes (things) that are part of your day-to-day world. List the various parts of a message. What is the difference between a synchronous and an asynchronous message? From a conceptual perspective, list some attributes and services of a class named BankAccount. From a specification perspective, list some attributes and operations of a class named BankAccount. From a conceptual perspective, list some attributes and services of a class named Rectangle. From a specification perspective, list some attributes and operations of a class named Rectangle. From a conceptual perspective, list some attributes and services of a class named Employee. From a specification perspective, list some attributes and operations of a class named Employee. List some modifier and query methods for a class named Automobile. Specify a pre-condition and a post-condition for an operation called \\(\\mbox{Factorial}(n)\\). Mathematical definition of \\(\\mbox{Factorial}\\) function is given by: \\[\\begin{equation*} \\mbox{ factorial}(n) = \\left \\{ \\begin{array}{ll} 1 &amp; \\mbox{ if } n =0 \\\\ 1 \\times 2 \\times 3 \\times \\cdots (n-2) \\times (n-1) \\times n &amp; \\mbox{ if } n \\geq 1 \\end{array} \\right. \\end{equation*}\\] Arrange the following objects into an inheritance hierarchy: Shape, Polygon, Oval, Triangle, Rectangle, Square, and Circle. Make necessary assumptions. Arrange the following objects into an inheritance hierarchy: BankAccount, SavingsAccount, CheckingAccount, MoneyMarketAccount, InterestCheckingAccount, StudentCheckingAccount, and SeniorCheckingAccount. Make necessary assumptions. Arrange the following objects into an inheritance hierarchy: Person, Student, Employee, Faculty, TenuredFaculty, NonTenuredFaculty, VisitingFaculty, Staff, SalariedStaff, HourlyStaff, UndergraduateStudent, GraduateStudent, PhDStudent, MSStudent, and NonDegreeSeekingStudent. Make necessary assumptions. Arrange the following objects into an inheritance hierarchy: LivingBeing, Animal, Plant, VascularPlant, NonvascularPlant, Vertebrate, Invertebrate, Mammal, Bird, Human, Reptile, JellyFish, Octopus, and Snail. Make necessary assumptions. Arrange the following objects into an inheritance hierarchy: Vehicle, Automobile, Bus, SchoolBus, CityBus, Motorcycle, Sedan, SportsCar, MiniVan, StationWagon, StreetMotorCycle, OffRoadMotorCycle, DualPurposeMotorCycle, and HarleyDavidson. Make necessary assumptions. List some problems associated with multiple inheritance. Define interface inheritance and implementation inheritance? What is delegation? Suggest one or more polymorphic methods which might be included in the design of these classes — Shape, Rectangle, Triangle, and Circle. Suggest one or more polymorphic methods which might be included in the design of these classes — Employee, SalariedEmployee, and HourlyEmployee. Suggest one or more polymorphic methods which might be included in the design of these classes — Automobile, Sedan, SportsCar, MiniVan, and StationWagon. What are the building blocks of UML? The following four exercises require the execution of Investment Management Application (IMApp) discussed in Section 2.6. Start the IMApp and login as Admin user (use admin/admin for username/password) and perform the following tasks in the sequence specified below: Create an issuer for a corporation named Hewlett-Packard. Create a common stock for Hewlett-Packard with ticker symbol HPC. Create a open price for stock HPC with the value $20.75. Create an investment manager named Roger Presscott with license to market equities in the State of Ohio. Make sure that the tasks in this exercise have been accomplished correctly by using the appropriate View menu item. Logout and exit the application. Start the IMApp and login as the investment manager Roger Presscott. If you don’t remember Mr. Presscott’s username and password, login as admin to view his details. Now perform the following tasks in the sequence specified below: Create a client named Chris Williams. Create an account for Chris Williams with an account balance of $6500.00. Execute a buy transaction for the above account to buy 100 shares of DELL common stock. Create a client named Alex Cross. Create an account for Alex Cross with an account balance of $5000.00. Execute a buy transaction for the above account to buy 200 shares of GE common stock. View client account summary. View portfolio for client Chris Williams. View portfolio for client Alex Cross. View monthly account statement for client Chris Williams. View monthly account statement for client Alex Cross. Change the password for investment manager Roger Presscott. Logout and exit the application. Start the IMApp and login as Admin user (use admin/admin for username/password) and auto update the prices for financial instruments. Start the IMApp and login as the client Alex Cross.If you don’t remember Mr.Cross’s username and password, login as his investment manager (Mr. Presscott) to view his details. Now perform the following tasks in the sequence specified below: View account summary. View account portfolio. View monthly statement. View account transactions. Compute unrealized gain/loss. Change the password for the client Alex Cross. View client’s personal information to observe the change in password. Logout and exit the application. Section ?? enumerated the functional requirements for the Investment Management Application. Perform requirements traceability assessment of the supplied IMApp system. Test drive the system and assess to what degree the IMApp implemented the listed requirements (IM and CL functions) by providing the following information: List the requirements that have been fully implemented. List the requirements that were partially implemented. List the requirements that were not implemented at all. List the features, if any, provided by IMApp that were not part of the requirements. Comment on usability of the application and suggest any recommendations for improvement. Assume that you want to operate an Internet based on-line store for selling flowers. Customers browse your store for the types of flower bouquets available and order them on-line. Because freshness is everything in flowers business, your business model is based on working with local flower vendors in the region of customers to fulfill orders. You are simply acting as an intermediary by fetching orders to the local flower shops. Your store showcases an integrated catalog of flower bouquets from various vendors across the regions you serve. Write an informal statement of the application domain requirements. You are the president of a temporary employment agency. Your business model is supplying workers on a temporary basis to various clients. You maintain information about employees, their skill sets, and experience. You also maintain information about clients (who are employers) and their need for temporary employees. Write an informal statement of the application domain requirements. Your professor has asked you to develop a system to help her with academic advising activities. Typically students go to an academic advisor to plan their course of study with the ultimate goal of earning a degree. What courses to take, when to take, prerequisite courses, required courses, elective courses, number of credit hours completed, number of credit hours required for the degree are some of the issues that are of interest to an academic advisor and advisee. Required and elective course requirements are further categorized into courses in the major, biological sciences, physical sciences, mathematics, language arts, music, and sports. Your academic advisor narrated the requirements of the system to you. You also had a couple of follow up and clarification discussions with the advisor. Write a summary of the application requirements for the academic advisor system. Abstraction is a mechanism which emphasizes the relevant aspects of a problem domain while intentionally suppresses the irrelevant and insignificant ones.↩ In the context of forms, the term field is widely used for an attribute.↩ "],
["c-basics.html", "3 C# Basics 3.1 Syntax and Semantics 3.2 BNF and EBNF 3.3 Variable and the .NET Types 3.4 HelloWorld Program 3.5 Commenting C# Program 3.6 A C# Program with Fields and Constants 3.7 Calculator Program 3.8 Operators 3.9 Expression Evaluation 3.10 Exception Processing 3.11 Chapter Summary 3.12 Exercises 3.13 Programming Projects", " 3 C# Basics In the previous chapter, we have approached solutions to problems from a top-down fashion. Our emphasis was on conceptual understanding of the problem, gathering requirements, performing preliminary Object-Oriented Analysis and Design (OOAD), and expressing OOAD artifacts in UML. In order to realize a solution, the classes in the class diagram need to be implemented using an object-oriented programming language. A major objective for this chapter is to introduce a subset of basic elements of the C# programming language. We also explain how to deal with runtime error conditions. Therefore, objectives for this chapter are to: Introduce the concepts of syntax and semantics of programming languages. Introduce BNF (Backus-Naur Form) and Extended BNF (EBNF) notation to precisely specify grammars which govern the syntax of programming languages. Introduce .NET types and variables. Illustrate the distinction between value and reference types. Illustrate the basics of writing and compiling a few simple C# programs. Explain ways of documenting C# programs. Discuss operators, precedence, and associativity, and expression evaluation. Illustrate exception handling — techniques for dealing with error conditions which are generated during program runtime. 3.1 Syntax and Semantics Consider the English language. There is a grammar associated with it. Given a sentence in the language, the rules of the grammar are used to check its syntactic correctness. In other words, the rules of the grammar specify how the various syntactic constructs of the language — parts of speech — can be combined to form syntactically valid sentences or strings. Semantics refers to the meaning of sentences in the language. It is possible that a sentence is syntactically correct but semantically meaningless. For example, The lush green forest is replete with colorless green trees is a syntactically correct but semantically meaningless sentence. Like the English language, syntax and semantics are associated with programming languages. The syntax of a programming language specifies how to construct syntactically correct programs. In other words, the syntax specifies the structure of strings in the language. At the highest level, a computer program is just one syntactic unit, which may be comprised of other syntactic units. Unlike English, grammars associated with programming languages are concise, precise, and formal. They need to be concise so that the grammar can be succinctly described and easily understood; precise so that there is no ambiguity in their specification; and formal so that they are amenable for checking the syntactic correctness of programs by a compiler. BNF or EBNF are used to describe grammars of programming languages. Semantics of a programming language describe the meaning of its syntactic units or strings. There are two types of semantics: denotational and operational. Denotational semantics is a technique for describing the meaning of computer programs in terms of mathematical functions by treating the programs and its syntactic units as functions. The properties of functions are proved by using the mathematical theory of functions, and especially domain theory. In contrast, operational semantics employs a set of rules which specify how the state of a computer changes while executing a program or a syntactic unit. The state of a computer is modelled by a number of components — stack, heap, various CPU registers. Each rule specifies certain pre-conditions on the contents of some components and their new contents (i.e., post-conditions) after the application of the rule. Table 3.1: EBNF notation for C# identifiers Input Notation digital := 0 | 1 | … | 9 letter := _ | a | b | c | … | z | A | B | … | Z identifier := letter {letter | digit} | @ {letter | digit} 3.2 BNF and EBNF BNF (Backus-Naur Form) is a syntactic meta-language (i.e., a language about a language). The meta-language is a formal notation for specifying the grammar that describes the syntax of a programming language. BNF was originally developed by John Backus and subsequent contribution from Peter Naur to describe the syntax of Algol 60 programming language. A few enhancements have been made to BNF resulting in Enhanced BNF (EBNF). EBNF is more succinct than BNF. However, BNF and EBNF are equivalent in terms of their expressiveness. EBNF employs a number of rules for describing the language. Each rule names a syntactic unit of the language and describes possible forms for a syntactic unit. EBNF also specifies which sequence of symbols is valid in the language. Syntactic units are also referred to as symbols of the language. There are two types of symbols: terminal and non-terminal. A non-terminal symbol is described in terms of other non-terminal (including itself) and terminal symbols. A terminal symbol is an atomic value which cannot be further decomposed into smaller components of the language. An identifier is a name that is used to uniquely identify syntactic units of a program — variables (or fields), keywords, methods, method parameters, among others. Consider C# rule for an identifier: it must begin with a letter, @ character, or underscore followed by one or more letters or digits. Table 3.1 shows how this rule is expressed in EBNF. Each row in the table defines a production rule for a non-terminal symbol: digit, letter, and identifier. The non-terminal letter is defined in terms of 53 terminal symbols: _, a, b, c, \\(\\cdots\\), z, A, B, C, \\(\\cdots\\), Z. The three center dots \\((\\cdots)\\) is a notation to represent the intermediate values of the sequence. The meta-symbol, :=, should be read as is defined as. In other words, the *letter can be replaced by an underscore, or by any one of lower or upper case alphabet. Terminal symbols are typeset in bold face. Sometimes, the terminal symbols are represented within quotes (e.g., a) to facilitate representing EBNF without dependence on text formatting such as bold and emphasized. We use bold face** to denote terminal symbols. The last row defines identifier as: either a letter followed by zero or more occurrences of letters or digits, or @ followed by one or more occurrences of letters or digits. The meta-symbol pair { and } indicate zero or more occurrences of a letter or digit. The choice between a letter or digit is indicated by the meta-symbol \\(\\vert\\). The rule says that an identifier cannot begin with a digit; just an underscore (i.e., _) by itself is a valid identifier; if the identifier starts with @, then it must be followed by one or more occurrences of letters or digits. According to this EBNF, though a variable name can legally begin with @ character such practice is discouraged. This provision is provided in C# for interfacing with programs written in other programming languages. Identifiers beginning with @ character are known as verbatim identifiers. You should convince yourself the conciseness, preciseness, and the formality offered by the EBNF. In fact, the power of EBNF will become more vivid as we embark upon describing more interesting syntactical units. Table 3.2 lists the meaning of various meta-symbols that EBNF uses. In summary, EBNF is used to describe the syntax of a programming language. Parser is a primary component of the compiler which checks for syntactic correctness of computer programs. There are tools such as YACC (Yet Another Compiler Compiler) that, given the grammar of a programming language in EBNF notation, can automatically generate the code for the Parser. Table 3.2: EBNF meta-symbols MetaSymbol Description := is defined as | Choice [] Optional {} Repetion,zero or more times {}+ Repetion, one or more times () Group items together, in mathematical sense ? The symbol (or group of symbols in parentheses) to the left of ? is optional (i.e., can appear 0 or 1 time) 3.3 Variable and the .NET Types In the simplest sense, variables are used to store values in computer memory. A variable is an alias or a symbolic name for the numeric address of one or more memory locations. Figure 3.1(a) shows several variables, their values, and numeric addresses of memory locations at which the values are stored. For example, the variable named actID references memory location 105 and the memory content at this location is 12345 (an integer value). In other words, actID is an alias for memory numeric address 105. When a computer program instruction references actID, it is referencing the value 12345 at memory location 105. It is more convenient to refer to memory locations by their symbolic names rather than by their numeric addresses. Figure 3.1: Value and referene types Variables are used for representing: inputs given to a program, intermediate results of a computation, and results produced by the program. These inputs and results can be of different types: string, integer, boolean, class, among others. Therefore, specifying the type associated with a variable is an integral part of declaring the variable. In other words, variables are typed. As discussed in Section 3.3.1, type is a generic term in the .NET Framework to collectively refer to signed integral types (e.g., integers, long integers), unsigned integral types (e.g., unsigned integer, unsigned long integer), floating point types, characters, strings, arrays, enumerations, structures, classes, interfaces, and delegates. The .NET Framework is discussed in Chapter ??. Chapter ?? discusses how characters, signed and unsigned integral types, and floating point types are represented in computer memory. Enumerations and structures are discussed in Sections ?? and ??, respectively. Section ?? provides a preliminary introduction to arrays and Chapter ?? discusses the same in greater detail. A preliminary introduction to classes is presented in Sections 3.4, 3.6, and 3.7; classes are discussed in detail in Chapters ?? and ??. Chapter ?? illustrates interfaces and Section ?? explains delegates. 3.3.1 Value and Reference Type The .NET types are grouped into two broad categories: value types and reference types as shown in Figure 3.2. Corresponding to these two types are value type and reference type variables. Value types are simple types and have their own copies of data. In other words, value types don’t share their data with each other. Therefore, it is not possible for operations on one value type to affect the value of another value type. For example, actID value in Figure 3.1(a) is not shared with any other variable. This is the core property of a value type. Assigning a new value to actID replaces the current value with the new value. In case of the pre-defined value types (char, bool, decimal, integral, and floating point types in Figure 3.2, the type is traditionally referred to as data type. Data type of a variable specifies three things: the type of data the variable can hold (e.g., integer, float); the range of values that the variable can hold; and the types of operations in which the variable can be used as an operand. For example, concatenation and substring operations are meaningful only on string variables whereas, arithmetic operations such as addition and multiplication are appropriate on integer and floating point variables. In other words, typing of variables helps to prevent meaningless operations such as adding a string value to an integer value. Figure 3.2: The .NET Types A reference type variable, rather than storing the information in itself, stores the memory location (or address) of that information. In other words, it stores a reference to the information. In contrast with the value types, reference types are more complex in terms of their memory layout and other aspects as discussed in Section ??. Consider Figure 3.1(b). The reference type finInstrOne points to memory location 200. What is stored at this location (i.e., 202) is not the value of the reference type, but the address of the memory location where the value can be found. The interpretation of this value is dependent on the reference type. For example, for reference variables of type class, the value is a block of memory locations. In the case of finInstrOne, the value comprises four other types: price, instrName, instrDesc, and instrIDType. Note that there is a level of indirection associated with the reference types. It takes longer to access the information stored by reference types — the first memory access provides the address where the information can be found, and the second memory access retrieves the information. Reference types enable sharing the same copy of information across multiple variables. In Figure 3.1(b), finInstrOne and finInstrTwo share the same copy of the information. Especially this is very significant if the information to be shared is large. However, operations on reference type variable can alter the values of another reference type variable. For example, changes to price value via finInstrOne entail changing the price value of finInstrTwo. Reference types facilitate storing information whose memory requirements are not known a priori. Also, reference types enable data to be moved around in memory (for right reasons) without affecting the consumers of the data. Assume that the information in memory block comprising of the addresses 202 – 205 has been moved to new locations 900 – 904. This movement is made transparent by storing the value 900 at memory locations 200 and 206. The Circle_b.cs program in Section ?? demonstrates the differences in the behavior of value and reference types. A real-world analogy to reference types is depicted by the following scenario. Assume that you change your address quite frequently. It is painstaking to inform all your business and personal acquaintances of your frequent moves. Your strategy then is to ask your acquaintances to always contact your parents to get your contact information every time they need to reach you. Each time you make a move you only need to inform your parents. Of course, the assumption is that your parents’ contact information doesn’t change. We focus on the value types for now. Various value types require different amounts of memory. In Figure 3.1(a), the floating point value type posQuantity requires two memory locations whereas, all other types require only one memory location 5. Once a variable is declared as a certain type, the C# compiler automatically tags the variable’s inappropriate usage (e.g., dividing an integer variable by a string variable) in the program at the time of compilation. C# requires all variables to be explicitly declared in the program before their usage. Such languages are referred to as strongly-typed in contrast with weakly-typed, wherein the compiler makes implicit assumptions about the data types of the variables that are used but not declared. Explicitly declaring variables contributes to developing safe and correct programs. From a compiler stand point, value types are allocated on the stack memory, whereas reference types are allocated on the heap memory 6. 3.3.2 Variable Naming Convention In C#, variable names can be of maximum length 256. However, it is unusual to have such long variable names. Variable names should be chosen such that they are self-describing. In other words, the variable name should suggest the intended purpose of the variable. For example, the name statePopulation for a variable suggests that it is used to store the population of a state. Though a variable name can legally begin with an underscore (see Table 3.6), but we discourage such names as they are often used in system software. Variable names in C# are case sensitive. For example, statePopulation, StatePopulation, and statepopulation are three distinct variable names. Keywords are special identifiers or reserved words that have special meaning in C#. As such we cannot use them as variables. C# keywords are shown in Table 3.3. Variable names can be all lower case, all upper case, or a combination of both. Which style is desirable is a matter of personal preference. However, it is a good programming practice to be consistent throughout. All upper case names are often used for constants. Consider the variable name statePopulation. Other syntactically correct forms include state_population, StatePopulation, and statepopulation. The naming of StatePopulation follows Pascal notation, where the first letter of every word in the variable is an upper case. The naming of statePopulation follows Camel notation, which is similar to Pascal notation except that the first letter of the first word is a lower case. Hungarian notation is another variation on Pascal notation, in which the variable name is prefixed with a string that indicates its data type. For example, the naming of intStatePopulation follows the Hungarian notation; int indicates that StatePopulation is an integer variable. Table 3.4 shows examples of variable names expressed in Camel, Pascal, and Hungarian notation. The table also depicts invalid variable names and reasons why they are invalid. Consider the name anlHouseholdInc. This could have been named as annualHouseholdIncome. Although the latter form is more descriptive, it takes more time to type and doesn’t necessarily contribute to program readability. On the other hand, a more succinct form such as anlHshldInc may rather be considered as cryptic. Irrespective of which style is chosen, consistency is the key. In real projects involving several programmers, variable naming conventions and other standards are established *a priori and are strictly adhered to. Table 3.3: C# keywords First Second Third Fourth Fifth Sixth Seventh Eighth abstract as base bool break byte case catch char checked class const continue decimal default delegate do double else enum event explicit extern false finally fixed float for foreach goto if implicit in int interface internal is lock long namespace new null object operator out override params private protected public readonly ref return sbyte sealed short sizeof stackalloc static string struct switch this throw true try typeof unit ulong unchecked unsafe unshort using virtual void volatile while Table 3.4: Valid and invalid variable names Camel Pascal Hungarian Remarks customerName CustomerName strCustomerName Customer Name, string type numOfChildren NumofChildren intNumOfChildren Number of children, string type prefCustomer PrefCustomer boolPrefCustomer Preferred customer, bool type anlHouseholdInc AnlHouseholdInc fltAnlHouseholdInc Annual household income, float type cmn_Rate Cmn_Rate fltCmn_Rate Commission rate, float type, Use of under-score is discouraged for readability reasons dateOfBirth% DateOfBirth% strDateOfBirth% DateOfBirth, string type. Invalid variable name. is not allowed in variable names 3.3.3 The .NET Types Table 3.5 shows various C# data types (first column), corresponding .NET System data types (second column), the range of values that the data type can hold (third column), and a description of the data type (last column). Note that the description indicates, where appropriate, the amount of storage required to store data type value. C# data types are simply aliases for .NET System data types. Significance of .NET System data types is discussed in Chapter ??. All the data types shown except object are referred to as intrinsic data types, meaning that the .NET Framework knows how to construct these data types in memory and to perform relevant operations on them. In contrast, for reference data types (e.g., object) we need to programmatically specify their construction and operations. Signed integer data types are used to store both positive and negative integers whereas, unsigned integer data types are used to store only positive integer values. For storing monetary values, decimal data type is recommended since its provides 28-digit precision. How integers, floating-point numbers, and characters are represented in memory is discussed in Chapter ??. An assortment of pre-defined value types is provided so that the correct one can be employed to suit the purpose. For example, if the purpose of a variable is to keep count of number of positions in a portfolio, any of the following types will suffice: sbyte, byte, short, ushort, int, uint, long, ulong. If we know that the number of positions can never be a negative value, we eliminate sbyte, short, int, and long right away since they should be used in situation requiring storing both positive and negative integer values. Furthermore, if we also know that the number of positions in any portfolio is at most 100, then byte is the right type. Choosing the right pre-defined value type is important for three reasons: safety and error checking, program efficiency, and memory requirements. Suppose that a variable is declared as ushort and a signed value is assigned to the variable during program runtime. The C# runtime system will generate an exception (or error condition) for this situation, which can be handled in the program by writing appropriate code (known as exception handling code). This contributes to program safety via error checking. Although it is possible to use a floating point type (e.g., float, double) in situations where an integer data type will do (e.g., sbyte, byte, short, ushort, long, ulong), the latter is preferred since floating point arithmetic is relatively more expensive (in terms of CPU time). Furthermore, declaring a variable of type ulong when ushort will suffice entails inefficient execution and inefficient memory utilization. Arithmetic operations on ulong values usually take longer than the same operations on ushort values; thus, the program takes longer to run. As noted in Table 3.5, ushort requires 16 bits of memory while ulong requires 64 bits of memory. Thus, it is important not only to select the right data type (e.g., float vs. long) but also the data type that conserves memory usage (e.g., ushort vs. ulong) by consulting Table 3.5. A word of caution is that if the values assigned to a variable are outside the range of values associated with the variable’s data type, then you will encounter overflow (i.e., the value assigned to the variable exceeds the maximum value allowed) and underflow (i.e., the value assigned to the variable is less than the minimum value allowed) exceptions. Declaring a variable consists of naming the variable and associating with it a type. Optionally, a variable can be assigned an initial value. This is referred to as initializing the variable. It is always a good practice to initialize variables before their use, preferably at the time of their declaration. EBNF for declaring and initializing variables and constants is shown in Table 3.6. The first two rows enumerate values for the non-terminals data type and accessMod (access modifier). The third row shows declaring a variable without initialization. The next row shows declaring and initializing a variable. We have used the terminal literal without defining it. Literal is any string whose value is compatible with the variable type to which it is assigned. The fifth row shows how more than one variable of the same type can be declared on the same line. The last row shows declaration and initialization of a constant. The static access modifier is associated with a constant by default. Note that constants need to be initialized at the time of their declaration. Access modifiers are discussed in Chapter ??. Constants are special variables whose values are fixed over their life time. Once a value has been assigned to a constant during the initialization, it can never be changed. In contrast, a variable can be reassigned values any number of times during its lifetime. Table 3.7 shows several examples of variable and constant declarations including initialization. Table 3.5: C# and .NET data types Type System_Type Range sbyte System.SByte -128 to 127 byte System.Byte 0 to 255 short System.Int16 -32,768 to 32,767 ushort System.UInt16 0 to 65,535 int System.Int32 -2,147,483,648 to 2,147,483,647 uint System.UIt32 0 to 4,294,967,295 long System.Int64 -9,223,372,036,854,775, 808 to 9,223,372,036,854,775, 807 ulong System.UInt64 0 to 18,446,744,073,709,551, 615 char System.Char U + 0000 to U + ffff float System.Single 1:5 x 10^-45 to 3:4 x 10^38 double System.Double 5.0 x 10^-324 to 1.7 x 10^308 bool System.Boolean true,false decimal System.Decimal 10^0 to 10^-28 string System.String Limited by computer memory object System.Object Encompasses all types Table 3.6: EBNF notation for variable and constant declarations Type Value datatype := bool | byte | char | decimal | double | float | uinit | int | long | object | sbyte | short | string | ulong | ushort accessMod := internal | private | protected | public varDecl := [accessMod] [static] data type varName; varDeclWithInit := [accessMod] [static] data type varName = literal; multVarDecl := [accessMod] [static] data type varName [,varName]; constDecl := [accessMod] [static] const data type varName = literal; Table 3.7: Declaring variables and constants Declaration_Example Explanation char gender = ‘M’; Declares gender as a variable of type char and initializes it to the character M byte numStudents = 35; Declares numStudents as a variable of type byte and initializes it to 35 uint statePopulation = 4294967295; Declares statePopulation as a variable of type unsigned integer and initializes it to 4294967295 string actName = ‘Savitar Trust’; Declares actName as a variable of type string and initializes it to the string ‘Savitar Trust’ bool lotOptionInd = true; Declares lotOptionInd as a variable of type boolean and initializes it to the value true ulong distanceToMoon = 18446440737095; Declares distanceToMoon as a variable of type unsigned long and initializes it to 18446440737095 float grossRevenue = 12234987654.65; Declares grossRevenue as a variable of type float and initializes it to 12234987654.65 int firstScore, secondScore; Declares two variables (firstScore, secondScore) as variables of type integer. Though legal, this practice of declaring two variable in the same line is discouraged const int maxGrossWeight = 97693492; Declares maxGrossWeight as an integer constant and initializes it to 97693492 const string stdGreeting = ‘Hi There’; Declares stdGreeting as an string constant and initializes it to ‘Hi There’ 3.4 HelloWorld Program HelloWorld program shown in Listing ?? just prints the string HelloWorld to the system console (i.e., computer screen). Type the source code shown in the second column of the table verbatim using Windows Notepad or some other text editor. The first column in the listing numbers program statements for cross referencing in the ensuing discussion, and is not part of the program. If you are using Notepad, its contents should look as Follows: Figure 3.3: HelloWorld.cs program with proper indentation Use the tab key on your keyboard for indenting the statements. Indentation is meant for program comprehension and has no effect on the program correctness. From the C# compiler’s point of view, programs shown in Figure 3.3 and Figure 3.4 are equivalent. Figure 3.4: HelloWorld.cs program without proper indentation However, the style shown in Figure 3.4 is forbidden as it obscures program structure and makes program comprehension difficult. Importance of this practice may not be apparent in this small program, but will come through vividly in typical real-world programs which run into thousands of lines code, and in some cases even into millions of lines. Furthermore, the code you develop will be subsequently maintained by other software engineers. Therefore, when you write code, always be aware that your code will be read, altered, and maintained by others during its life time. Save your file as HelloWorld.cs. The extension cs denotes that it is a C# source file. Note that C# programs are case sensitive and pay attention to the case of the alphabet when you type the program. 3.4.1 Dissection of the HelloWorld Program Line 1 is one type of a comment. This type of comment in C# programs are preceded by //. Anything that comes after // is ignored by the C# compiler. We discuss comments in Section 3.5. C# keywords in the program are shown in italics 7. Namespace is a mechanism to resolve name conflicts. Think of how cities/towns are named in the United States. In general, a city name is unique only within the context of a state 8. For example, if we mention Jackson as a city name, there is ambiguity about which Jackson we are referring to since the states Mississippi, Tennessee, New Jersey, and Michigan all have cities with the name Jackson. One way to resolve name ambiguity is to specify the city name along with the state in which it is located. Similar situation exists in naming classes. In large projects, typically there are hundreds (or even thousands) of classes, which are possibly developed by different groups and some may even come from third party vendors. It is possible that two groups might have selected the same name for two different classes. In isolation this creates no problems. However, when code from different groups is assembled, class name conflicts create serious problems. One way to avoid this problem is through the namespace concept. The code developed by each group (or even each team member) is put into a separate namespace. Under this scenario, class names need to be unique only within a namespace. .NET namespaces are further discussed in Section ??. Line 2 indicates that we are using a namespace called System. The keyword using is called a compiler directive. It instructs the compiler to resolve any type name conflicts using the System namespace. In the absence of a using directive, one has to fully qualify the type in form of namespacename.typename. Without the directive, we should have written line 9 as: System.Console.WriteLine (Hello World); System namespace defines various classes including Console, which is used in Line 9. Note the semicolon (;) at the end of Line 2 to indicate the end of C# program statement. For the reasons discussed above, we like to keep whatever we develop in this program under a separate name space called CSFund1.Chap1.HellowWorldApp. Note that a period is allowed in the namespace. Line 3 accomplishes this. The parenthesis pair { (line 4) and } (line 12) defines the scope of this namespace. That is, everything enclosed between the lines 4 and 12 is in the CSFund1.Chap1.HellowWorldApp namespace. The text between the lines 5 and 11 defines a class named HelloWorld. Line 5 defines the class name as HelloWorld. A C# class, in general, consists of the following members: fields, properties, constants, methods, indexers, events, and operators. However, our HelloWorld class has only one method named Main. Recall that methods are the actual code that implements the behavior of a class. The Main() method is defined by the lines 7 through 10. Line 7 declares this method. The keyword public is an access modifier, which indicates that the method is accessible from any other class; static specifies that the method is a static method (i.e., you don’t need to instantiate the class to invoke the method) 9; void indicates that the method doesn’t return any value to the invoker of the method. The parentheses, ( and ), after the method name Main are used to enclose placeholders (referred to as method parameters) that refer to values passed to the method by the invoker of the method and the values returned by the method to the invoker. In this case, the method doesn’t take any parameters. The method has no variable declarations; if present, they need to be inserted between the lines 6 and 7. The parentheses in lines 8 and 10 delimit the method implementation. The method has only one statement, which prints the string Hello World to the console. For this purpose, we make use of Console class defined in the System namespace (line 2). Console class has a static method named WriteLine, which takes a string as input and processes it according to certain rules for display on console. In our context, it simply displays the string enclosed in double quotes (i.e., Hello World) on console. Indentation using tabs or spaces, and spaces between the keywords, and between other syntactic units are referred to as white space. All white space is removed by the C# compiler before it invokes the parser to validate the syntactic correctness of the program. Figure 3.5: Executing cmd program to open a DOS Window 3.4.2 Compiling the HelloWorld Program It is assumed that your computer is using Windows XP operating system and the .NET SDK (Software Development Kit) is installed in C:WINDOWSMicrosoft.NETFrameworkv1.1.4322 directory. Note that the directory name v1.1.4322 is also the version number of the .NET SDK. The C# compiler, csc.exe, is in the this directory. Your system PATH should include the above directory. It doesn’t matter in which directory the SDK is installed provided that the directory is included in the system PATH. You may need to seek your instructor’s or system administrator’s help for setting up the PATH correctly. Open a DOS command window by running cmd program as shown in Figure 3.5. Change to the directory where you have saved HelloWorld.cs file by executing cd (change directory) command (See Figure 3.6). In our case, it is in C:\\(\\backslash\\)Test directory. Therefore, we execute the following command in DOS Window: cd C:\\(\\backslash\\)Test Make sure that you confirm that the file exists in this directory by executing DOS dir command. Next, compile HellowWorld.cs program by executing the following command: csc HelloWorld.cs If you have typed the program correctly, it should compile without any errors as shown in Figure 3.6. Verify that the compiler has produced an executable file named HellowWorld.exe by executing DOS dir command or using Windows file explorer. If the PATH is not correctly set, you may get an error: csc is not recognized as an internal or external command, operable program or batch file. As a quick fix to this problem, execute the following command to compile the program (assuming that the .NET SDK is installed in C:\\(\\backslash\\)WINNT\\(\\backslash\\)Microsoft.NET\\(\\backslash\\)Framework\\(\\backslash\\)v1. C:\\WINNT\\Microsoft.NET\\Framework\\v1.0.3705\\csc HelloWorld.cs Another source of errors can be forgetting to include the file extension cs in the above command. Run the program by typing the executable name: HelloWorld. Figure 3.6 shows the results of running the HelloWorld program. Figure 3.6: HelloWorld.cs program run results 3.5 Commenting C# Program C# supports three forms of comments: single-line, delimited, and documentation. A Single-line comment starts with the characters // and extend to the end of the source line as shown in line 1 of Listing ??. Single-line comments may also start after the end of a program line as shown in lines 6–9 of Listing ??. Delimited comments start with the character pair /* and end with the pair /. Delimited comments may span across multiple lines. Lines 4 – 8 of Listing ?? shows a delimited comment. Comments do not nest within each other. The character pair / and / have no special meaning within a // comment, and the character pair // and / have no special meaning within a delimited comment. We insert single-line and delimited comments into programs to provide information that will help maintain and enhance the program. Comments at the beginning of a piece of code (e.g., class) provide a functional description of the code (i.e., what function does the code accomplish?). Comments may be interspersed throughout the code as appropriate (see Listing ??. Carefully chosen variable names are self-documenting and eliminate the need for comments to explain their function. Comments should be terse, precise, and shouldn’t repeat what is in the code. The third type of comments — documentation comments — is a mechanism for programmers to document their code using a special comment syntax that contains Extensible markup Language (XML) text. Such comments are one-line, always start with the character triple ///, and precede source code elements such as user-defined type (e.g., class, interface, and delegate) or a member (e.g., field, event, property, indexer, or method). Documentation comments are used to direct a tool to produce XML from those comments and the source code elements. The XML generation tool is called the documentation generator. The output produced by the documentation generator is called the documentation file, which is used as input to a documentation viewer. The latter is a tool intended to produce some sort of visual display of type information and its associated documentation. Documentation comments are beyond the scope of this book. 3.6 A C# Program with Fields and Constants This program demonstrates declaring and initializing fields and constants, reading data from and writing data to console, assignment statements, and arithmetic expressions. We refer to this program as ConsoleReadWrite and is shown in Listing ??. In C#, variables at the class level are called fields. A constant is a field whose value cannot be changed once a value is assigned. Line 9 declares and initializes PI — a constant of type double — to the literal 3.1415. Similarly, line 10 declares and initializes stdGreeting — a string constant — to the literal Hi, there! By default, all constants are static. Recall that constants declared at the class level are shared among all instances of the class and are history-sensitive. Line 11 declares and initializes an integer field called age. Line 14 writes the string enclosed in double quotes to the console after substituting the value of PI for {0}. This string after substitution reads The Value of PI is: 3.1415. Line 15 writes the string Hi, there! How Old are You? to the console. In response, we assume that the user has entered the value 18 using the keyboard. Line 16 is an example of an assignment statement. The expression on the right hand side of the symbol =, Int32.Parse(Console.ReadLine()), is evaluated and assigned as the value of the variable to the left of =, which is age. The ReadLine() static method of the Console class reads and returns input typed on the console, which subsequently becomes input to the Parse() method of the Int32 class. What is read from the system keyboard is just a string of characters. The Parse() method of the Int32 class interprets this string as an integer. Line 17 is similar to the lines 14 and 15, and prints the string This Year You are 18 Years Old! to the console. Line 18 increments the value of the variable age by 1. Line 19 prints the string Next Year You Will be 19 Years Old! Assignment statements are of the form: variable = expression. Evaluating the expression should result in a value whose data type is same as the data type of the variable. Type the ConsoleReadWrite program using Windows Notepad editor and save it as ConsoleReadWrite.cs. Compile the program and run it. Verify that it produces correct results as shown in Figure 3.7. Microsoft Visual Studio.NET is an Integrated Development Environment (IDE) for developing C# programs. It offers a rich set of tools for editing, compiling, running, debugging, and packaging C# programs. Visual Studio.NET is discussed in Section ??. Figure 3.7: ConsoleReadWrite.cs program run results 3.7 Calculator Program The program shown in Listing ?? illustrates typical scenario of programming with classes. There are two classes: Calculator (lines 4 – 34) and CalculatorApp (lines 35 – 58). The first one provides arithmetic functionality and the latter exercises this functionality. The Calculator class defines seven methods: Add, Sub, Mult, Div, Mod, Power, and Absolute. The first five methods, given two integers as the values for their method parameters, compute and return addition, subtraction, multiplication, division, and modulus of parameter values. The sixth method, given two values \\(a\\) and \\(b\\) of type double, computes \\(a^b\\) as a double value. The last method, given an integer value as parameter, returns the absolute value of the parameter. Consider the Add() method defined in lines 6 – 9. Line 6 is called the method signature. The keyword public is the access modifier indicating its visibility — who can invoke the method; public allows accessing the method from any where. The keyword int following the public specifies that the method returns a value of type int. Add is the method name. The invoker of this method need to provide a value for each of the method parameters \\(n1\\) and \\(n2\\). One way for a method to return a value to the invoker is by using the return keyword. The method’s logic is in line 8 — just returns the sum of the method parameter values \\(n1\\) and \\(n2\\). If the Add method signature were: public void Add (int \\(n1\\), int \\(n2\\)), the method is not allowed to return a value as the keyword void prohibits it. As we see in other programming examples, there are additional ways for a method to return values — using the ref and out method parameter qualifiers. Lines 6 – 9 show the right indentation for the code. Notice that the Mod() method defined in lines 22 – 25 has static keyword in its method signature. Therefore, Mod() is a static method. As we show later that invoking Mod() method doesn’t require instantiating the Calculator class. In contrast with the first five methods, Power() has method parameters of type double and also returns a value of type double (line 26). In line 28, the Pow() method of the Math class, a pre-defined class from System namespace, is invoked. The method signature for Power() is: public static double Power (double \\(x\\), double \\(y\\)). The parameter values of Power(), baseNum and expoNum, are used for invoking Pow(). Note that Pow() is a static method and returns double. The Power() method simply returns the value returned by Pow. This is only possible since the return types of Pow() and Power() are the same. How do we know that there exists a Math class? How do we learn about its method signatures? Math is one of the several classes defined in System namespace. The .NET Framework Class Library (FCL) comes with thousands of classes ready for use. In fact, your C# programming productivity depends heavily on your mastery of the FCL. Several tools are available to exploring the library — IL Disassembler, Windows Class Viewer, Class Browser Web Application, Visual Studio.NET Object Browser — which are discussed in Section ??. Using Windows Class Viewer, one can search for Framework Class Library classes and their methods as shown in Figure 3.8. The last method, Absolute(), given an integer, returns its absolute value. Absolute() simply invokes Abs() method of the Math class with its parameter value, and returns the value returned by Abs(). Figure 3.8: ConsoleReadWrite.cs program run results The objective of CalcApp class (lines 35 – 58) is to demonstrate creating an instance of Calculator class and invoking its non-static methods. It also shows how to invoke static methods. Such classes are generically referred to as client classes; they consume the services or functionality provided by the other classes. Lines 39 – 40 declare and initialize two integer variables, \\(num1\\) and \\(num2\\). Line 41 declares another integer variable, result. Note that \\(num1\\), \\(num2\\), and result are method-level variables and are local to the method. In other words, local variables are not known outside the method in which they are declared. From the program readability and understandability point of view, each variable should be placed on a separate line. Line 44 prints the values of \\(num1\\), \\(num2\\), and Calculator.Mod(num1, num2). Note that Mod() is a public static method and the syntax used for its invocation: Calculator.Mod(num1, num2). It requires prefixing the method name with the class name (i.e., Calculator) and supplying the necessary parameters (\\(num1\\) and \\(num2\\)). In contrast, invoking public non-static methods require an instance (i.e., an object reference) of the class as shown below. Line 46 declares and creates an instance, \\(myCalc\\), of the Calculator class. The unary operator new is used to create the class instance. Constructor is a special method which is used to create an instance of a class. C# supplies a default constructor for each class we define. However, we can override this by providing our own constructor. Since we didn’t provide a constructor, the new operator will use the default one. Note that the type of \\(myCalc\\) is Calculator — a reference type. It is also known as an object reference of type Calculator. Now that we have an object reference to the Calculator class, we can invoke any of the non-static public methods of the class using the \\(myCalc\\). The rest of the program essentially does methods invocation. Line 48 invokes the Add() method using \\(num1\\) and \\(num2\\) and the value returned is assigned to the variable result. Note that the return type of the Add() method and the type of result variable should be compatible. For now, let us assume that compatibility means that they should be of the same type. Line 49 writes to console the string in the double quotes after substituting the values of \\(num1\\), \\(num2\\), and result for *0*, *1*, and *2*. Line 50 is equivalent to lines 48 and 49. Instead of first assigning a value to result (line 48) and using the result in the WriteLine method (line 49), line 50 invokes the Add() method directly from the WriteLine statement. Lines 51 – 53 print the results returned by Sub(), Mult(), and Div() methods. Recognize that \\(num1\\) and \\(num2\\) are integers. They cannot be used for method parameter values when invoking Power(), as the latter expects parameter values of type double. One way to circumvent this problem is to explicitly convert integer values to double type using the type casting operator: (double) \\(num1\\) converts \\(num1\\) value to a double value (line 54). Converting an int into double is information-preserving while the reverse is not necessarily true. C# compiler does an implicit type casting in information-preserving situations. Line 55 assigns a negative value to \\(num1\\) and is used in the invocation of the Absolute() method. The results of running the Calculator.cs program are shown in Figure 3.9. Figure 3.9: Calculator.cs program run results 3.8 Operators An operation consists of an operator and one or more operands. Operators that require only one operand are known as unary; those that require two are referred to as diadic (or binary); those that require three are named ternary. Examples of arithmetic operators include addition, multiplication, exponentiation, ceiling, floor, and logarithm. The first three are binary whereas, the last three are unary. An operation is represented as an expression. In the simplest case involving a diadic arithmetic operator such as addition, the following are examples of arithmetic expressions: \\(2 + 5\\); \\(*numStudents* + 1\\). In the first example, the operands are the literal constants 2 and 5; in the second, the operands are the variable numStudents and the literal constant 1. 3.8.1 Operator Precedence An expression can contain multiple operators as in: \\(2 \\times 15 + 25\\). Furthermore, compound expressions are composed from simple expressions in constrained ways. The expression \\(2 \\times 15 + 25\\) yields different results based on which operator is evaluated first. There are two ways to evaluate this expression: multiplication followed by addition, and addition followed by multiplication. The first way results in 55 and the second one yields 80. However, expression evaluation need to be deterministic — should always yield the same value. This leads us to the notion of operator precedence, which specifies the order in which the operators should be evaluated. Multiplication operator has higher precedence over addition. Therefore, the correct way to evaluate \\(2 \\times 15 + 25\\) is to apply the multiplication operator first followed by addition. Therefore, the correct value of \\(2 \\times 15 + 25\\) is 55. Parentheses can be used to explicitly indicate operator precedence as in: \\((2 \\times 15) + 25\\). We strongly recommend using parentheses to disambiguate order of operator application. 3.8.2 Operator Associativity Consider the expression 30 - 10 - 5. Since it has multiple occurrences of the same operator, precedence rules don’t help us in determining which one of the following order of operator application is correct: (30 - 10) - 5 or 30 - (10 - 5). This is where operator associativity comes into play. Associativity determines which side of an expression should be evaluated first. If an operator is left associative, the expression to the left of the operator is evaluated first. On the other hand, right associativity requires that the expression to the right of the operator be evaluated first. Since minus \\((-)\\) is left associative, the expression 30 - 10 - 5 is equivalent to (30 - 10) - 5. Table 3.8: C# operators Type Operators Primary (a), a:b, f (a), a[b], a++, a–, new, typeof, sizeof, checked, unchecked Unary +, -, !, ~ , ++a, –a, T(e) Multiplicative *, /, % Additive +,- Shift &lt;&lt; , &gt;&gt; Relational &lt; , &lt;_ ; &gt;; &gt;_, is, as Equality ==,!= Logical AND &amp; Logical XOR ^ Logical OR | Conditional AND &amp;&amp; Conditional OR || Conditional ?: Assignment =, *=, /=, %=, +=, -=, &lt;&lt;=, &gt;&gt;=, &amp;=, ^=, | C# provides an assortment of operators as shown in Table 3.8. Primary operators have the highest precedence, which decreases as we traverse down the table rows, ending in assignment operators having the lowest precedence. All diadic operators, except the assignment operator, are left-associative. That is, they are evaluated from left to right. Conditional and assignment operators are right associative, meaning that they are evaluated from right to left. For example, the expression \\(x=y=z\\) is equivalent to \\(x=(y=z)\\), since the assignment operator, \\(=\\), is right associative. We provide a brief and generic description of the operators listed in Table 3.8. Their precise behavior depends on the data types of the operands — for example, int vs. float, value types vs. reference types.These nuances are discussed in detail when the operators are used in C# programs. The grouping of the operators shown in the table is motivated by the goal to depict operator precedence. However, in the following, they are grouped differently to better facilitate their discussion. 3.8.3 Primary Operators Parenthesis operator of the form, (a), is used to disambiguate operator precedence in mathematical expressions and method calls. The dot (.) operator in expressions of the form \\(a.b\\) is used to specify the member \\(b\\) of the class or structure \\(a\\). \\(f(a)\\) form of parenthesis operator is used to specify the list of input parameter(s), a, when invoking the method \\(f\\). The square brackets in \\(a[b]\\) are used to specify an index \\(b\\) into the array \\(a\\). Array is a data structure to hold a list of elements, and enables referencing the elements by their index or location position. Arrays are discussed in Chapter ??. o create instances of a class, the new operator is used. The operator typeof (e.g., typeof(expression)) returns a string that identifies the type of an expression. It returns type information as a string. There are six possible values that typeof returns: number,string,boolean, object, function, and undefined.The parentheses are optional in the typeof syntax. The sizeof operator (e.g., sizeof(type)) is used to obtain the size (in bytes) for a value type. This operator cannot be overloaded and can only be used in unsafe mode. The checked and unchecked operators are used to control the overflow-checking context for integral-type arithmetic operations and conversions. Overflow occurs when the value to be stored is outside the data type’s range of values. In a checked context, arithmetic overflow raises an exception; in an unchecked context, arithmetic overflow is ignored and the result is truncated. 3.8.4 Type Casting and Testing Operators In the operation \\((T)e\\), the value of the expression \\(e\\) is explicitly converted to value of type \\(T.\\) This operation is referred to as explicit type casting operation. The operator is used to dynamically check if the run-time type of an object is compatible with a given type. The result of the operation \\(e\\) is \\(T\\), is a boolean value indicating whether the expression \\(e\\) can successfully be converted to type \\(T\\). The as operator is used to explicitly convert a value to a given reference type. Unlike the cast expression \\((T)e\\) (Section 3.8.3, the as operator never raises an error condition (or an exception). If the indicated conversion is not possible, the result is simply set to null. Both is and as are illustrated in Chapter ??. 3.8.5 Arithmetic Operators The unary operator, +, is used in the form +(operand). It simply returns the operand. On the other hand, -, returns the negative value of its operand. Arithmetic operators \\(\\ast, /, \\%, +, -\\) are diadic and require numeric operands — int, uint, long, ulong, float, double, and decimal. The remainder operator, %, computes the remainder of the division \\(a / b\\). This operator is also known as modulus operator. The operators \\(\\ast, /, +,\\) and \\(-\\) compute multiplication, division, addition, and subtraction, respectively. \\(+ +\\) and \\(- -\\) are called increment and decrement operators. They are used on numeric values. \\(a\\!+\\!+\\) increments the value of \\(a\\) by 1 and \\(a\\!\\!-\\!-\\) decrements the value of \\(a\\) by 1. This form of increment and decrement operators are called post-increment and post-decrement operators to distinguish them from pre-increment \\((+\\!+\\!a)\\) and pre-decrement \\((-\\!-\\!a)\\) counterparts. There is no difference between the two versions if the operations are used in isolation. Distinction exists if the operators are embedded as part of other expressions. The operation \\(a\\!+\\!+\\) increments the value of \\(a\\) by 1 after the value of \\(a\\) has been used in expression evaluation. Likewise, \\(a\\!-\\!-\\) decrements the value of \\(a\\) by 1 after the value of \\(a\\) has been used in expression evaluation. In contrast, \\(+\\!+\\!a\\) first increments the value of \\(a\\) by 1, and the incremented value is used in the expression evaluation. Similarly, \\(-\\!-\\!a\\) first decrements the value of \\(a\\) by 1, and the decremented value is used in the expression evaluation. 3.8.6 The Conditional Operators The \\(?\\): operator is called the conditional operator. A conditional expression of the form, $ bexp , ? , a ! ! ! : ! b$, first evaluates the condition bexp. If bexp is true, \\(a\\) is evaluated and is returned the result of the operation. Otherwise, \\(b\\) is evaluated and is returned as the result of the operation. A conditional expression never evaluates both \\(a\\) and \\(b\\). The conditional operator is right-associative — operations are grouped from right to left. For example, an expression of the form \\(a \\,? \\, b \\! : \\! c \\,? \\, d \\! : \\! e\\) is evaluated as \\(a \\,? \\, b \\!: \\! (c \\,? \\, d:\\! e)\\). Since \\(? \\! \\! :\\) takes three arguments (inputs), it is also referred to as the ternary operator. Listing ?? demonstrates how the conditional operator works. 3.8.7 Increment/decrement, Shift, and Conditional Operator Program Listing ?? exemplifies how increment/decrement, shift, and the conditional operators work. The results of running this program are shown in Figure 3.10. MiscOpr class (lines 5 – 29) has only the Main() method (lines 7 – 28). Line 10 prints the value of local variable \\(x\\) declared and initialized in line 9. The printed value should be 10. The expressions \\(x+\\!+\\) and \\(+\\!+x\\) by themselves as complete statements are equivalent. Line 12 post-increments \\(x\\) whereas line 13 pre-increments \\(x\\). After executing line 13, the value of \\(x\\) should be 12 (i.e., \\(10 + 1 + 1\\)). Lines 14 and 15 post- and pre-decrement \\(x\\). Therefore, the value of \\(x\\) printed by line 16 should be 10 (i.e., \\(12 - 1 - 1\\)). ow consider line 17. First, \\(x\\) is pre-incremented, then multiplied by 2, and this result is assigned to \\(y\\). Hence, the values of \\(x\\) and \\(y\\) printed by line 18 should be 11 and 22. In contrast, in line 19, the current value of \\(x\\) (i.e., 11) is used in the expression, the result is assigned to \\(y\\), and then \\(x\\) is (post-)incremented. Therefore, the values of \\(x\\) and \\(y\\) printed by line 20 should be 12 and 22. Line 22 performs a left shift on \\(x\\) by four bits. If we sidestep overflow issues, left shifting \\(x\\) by one bit is equivalent to multiplying \\(x\\) by 2. Hence, the value of \\(x\\) after line 22 should be 192 (i.e., \\(12 \\ast 2 \\ast 2 \\ast 2 \\ast 2)\\). Line 23 performs right shifting of \\(x\\) by two bits. The effect of right shifting of \\(x\\) by one bit is equivalent to dividing \\(x\\) by 2. The value of \\(x\\) after executing line 23 should be 48 (i.e., \\(192 \\div 4\\)), which is verified by the output of line 24. Finally, line 26 illustrates the conditional operator. First, the relational expression \\(x &lt; 10\\) is valuated. It evaluates to false since \\(48 &lt; 10\\) is false. Hence, \\(y\\) is assigned the result of evaluating the expression \\(x \\ast 3\\), which is 144. The output of line 27 verifies this. Figure 3.10: MiscOpr.cs program run results 3.8.8 Logical OPerators There are two types of logical operators: logical boolean and logical bitwise. Logical boolean operators require their operands to be of type boolean and produce a result which is also of type boolean. On the other hand, logical bitwise operators work on the binary representation of their operands. Logical operators include &amp;, \\(\\wedge\\), \\(\\vert\\), \\(!\\), \\(\\sim\\), \\(!\\!=\\), &amp;&amp; and \\(\\vert\\vert\\) Shift operators are a type of bitwise operators and include \\(&lt;\\!&lt;\\) and \\(&gt;\\!&gt;\\). Table 3.9 summarizes logical operators. 3.8.8.1 Logical Boolean Operators First consider the boolean versions of the logical operators. The &amp;, \\(\\wedge\\), and \\(\\vert\\) operators’ are diadic and their behavior is discussed in detail in Section ??. The result of \\(a \\&amp; b\\) is true if both \\(a\\) and \\(b\\) are true; otherwise, the result is false. The result of \\(a \\wedge b\\) is true if \\(a\\) is true and \\(b\\) is false, or if \\(a\\) is false and \\(b\\) is true; otherwise, the result is false. When the operands are of type bool, the \\(\\wedge\\) operator computes the same result as the \\(!\\!=\\) operator. The result of \\(a \\vert b\\) is true if either \\(a\\) or \\(b\\) is true; otherwise, the result is false. The negation operator, \\(!\\), takes one operand and negates it. It returns true if its operand is false; otherwise, returns false. The \\(\\sim\\) operator is not applicable for boolean operands. The operators &amp;&amp; and \\(\\vert\\vert\\) are conditional versions of the &amp; and \\(\\vert\\) operators. Hence, they are referred to as the conditional logical (boolean) operators. The operation \\(a \\,\\, \\&amp;\\&amp; \\,\\,b\\) corresponds to \\(a \\, \\&amp; \\, b\\), except that \\(b\\) is evaluated only if \\(a\\) evaluates to true. The operation \\(a \\, \\vert \\vert \\, b\\) corresponds to \\(a \\, \\vert \\, b\\), except that \\(b\\) is evaluated only if \\(a\\) evaluates to false. For this reason, they are also referred to as the short-circuit logical operators. 3.8.8.2 Logical Bitwise Operators If the operands are integers (i.e., int, uint, long, ulong), the &amp; operator computes the bitwise logical AND of the two operands; the \\(\\wedge\\) operator computes the bitwise logical exclusive OR (XOR) of the two operands; and the \\(\\vert\\) operator computes the bitwise logical OR of the two operands. For enumeration type operands, bitwise operators simply perform the logical operation on the underlying data types of the two operands (as in the case of integer types). The \\(\\sim\\) operator performs a bitwise complement operation (see Section ??) on its operand. Bitwise complement operators are predefined for int, uint, long, and ulong. Table 3.9: C# operators Boolean_Symbol Name Example Remarks Bitwise_Symbol Names Examples Remark Short_Circiut Namess Exampless Remarkss Shift Nam Exmpl Remk &amp; Logical-AND a&amp;b Evaluates to true if both a and b evaluate to true &amp; Logical-AND a&amp;b Performs bitwise logical ANDing of a and b. The result is interpreted as a binary value &amp;&amp; Control-AND a&amp;&amp;b Corresponds to a&amp;b, except that b is evaluated only if a evaluates to true &lt;&lt; Left a&lt;&lt; bitcount Perform left shift on a by number of bits = bit count | Logical-OR a|b Evaluates to true if any of a and b evaluates to true | Logical-OR a|b Performs bitwise logical ORing of a and b. The result is interpreted as a binary value &amp;&amp; COntrol-OR a||b Corresponds to aj b, except that b is evaluated only if a evaluates to false &gt;&gt; COntrol-OR a&gt;&gt; bitcount Perform right shift on a by number of bits = bit count ^ Logical-XOR a^b Evaluates to true if and only if one of the operands evaluates to true and the other evaluates to false; otherwise, evaluates to false ^ Logical-XOR a^b Performs bitwise logical XORing of a and b. The result is interpreted as a binary value &amp;&amp; Control-AND a&amp;&amp;b Corresponds to a&amp;b, except that b is evaluated only if a evaluates to true &lt;&lt; Left a&lt;&lt; bitcount Perform left shift on a by number of bits = bit count ! Logical Negation !a Evaluates to true if a is false; otherwise, evaluates to false ~ Logical Complement ~a Performs bitwise complement of a. The result is interpreted as a binary value &amp;&amp; COntrol-OR a||b Corresponds to aj b, except that b is evaluated only if a evaluates to false &gt;&gt; COntrol-OR a&gt;&gt; bitcount Perform right shift on a by number of bits = bit count 3.8.8.3 Logical Operators Program Listing ?? exemplifies logical operators. The results of running the program is shown in Figure 3.11. Line 11 prints out the values of \\(x\\) and \\(y\\) declared and initialized in line 9. Line 13 evaluates the expression \\(x &lt; 10 \\, \\&amp; \\, y &gt; 10\\) and prints the result. The first operand, \\(x &lt; 10\\), evaluates to true since \\(5 &lt; 10\\). The second operand, \\(y &gt; 10\\) evaluates to false since \\(10&gt; 10\\) is false. Since both the operands are not true, the operator \\(\\&amp;\\) returns false. Line 14 prints out true since \\(x &lt; 10\\) of the expression \\(x &lt; 10 \\, \\&amp; \\, y &gt; 10\\) evaluates to true. Line 15 prints out true since for the operator \\(\\wedge\\), one of the operands (\\(x &lt; 10\\)) evaluates to true and the other (\\(y &gt; 10\\)) evaluates to false. Line 16 prints false since the operand \\((x &lt; 10)\\) evaluates to true and negation operator \\((!)\\) negates it to false. To understand what is printed by lines 18–22 requires an understanding of how signed and unsigned integers are represented in binary form (Section ??. Consider the \\(x \\&amp; y\\) operation on line 18. The binary representation of \\(x\\) is 0101 (= 5) and the same for \\(y\\) is 1010 (= 10). Bitwise ANDing gives 0000 (= 0). Likewise, bitwise ORing (line 19) gives 1111 (= 15). Lines 24 and 25 illustrate short-circuit evaluation of boolean expressions. Since the first operand \\(x &gt; 5\\) of the expression $ a &gt; 5 &amp;&amp; y &lt; 10$ evaluates to false, the rest of the expression is not evaluated and line 24 prints false. Note that the expression evaluates to false irrespective of the value of the second operand evaluation. In line 25, the first operand \\(x &lt; 10\\) evaluates to true and the line prints true. The second operand \\(y &gt; 10\\) is evaluated only if the first operand has evaluated to false. Figure 3.11: LogicalOpr.cs program run results Table 3.10: Relational operators’ behavior Expression Description a==b true if a is equal to b; false otherwise a!=b true if a is not equal to b; false otherwise a&lt;b true if a is less than b; false otherwise a&gt;b true if a is greater than b; false otherwise a&lt;=b true if a is less than or equal to b; false otherwise a&gt;=b true if a is greater than or equal to b; false otherwise 3.8.9 Relational Operators The operators \\(= =, !\\!=, &lt;. \\leq, &gt;, \\geq\\) are called relational or comparison operators. They are all diadic and return a boolean value as result. Table 3.10 summarizes results of relational operations. 3.8.10 Assignment Operators The assignment operators: \\(=\\), \\(\\ast \\! =\\), \\(/ \\!\\! =\\), \\(\\% \\! \\!=\\), \\(+ \\! \\!=\\), \\(- \\! \\!=\\), \\(&lt; \\! &lt; \\! =\\), \\(&gt; \\! &gt; \\! =\\), \\(\\&amp; \\!\\! =\\), \\(\\wedge \\! \\! =\\), and \\(\\vert \\! \\! =\\), assign a new value to a variable, a property, an event, or an indexer element. Properties are discussed in Section ??, events in Section ??, and indexers in Section ??. Assignment statements are of the form: leftOperand assignmentOperator rightOperand. The leftOperand must be an expression classified as a variable, a property access, an indexer access, or an event access. The operator, \\(=\\), is referred to as the simple assignment operator. It assigns the value of the rightOperand to the variable, property, or indexer element given by the leftOperand. The left operand of the simple assignment operator may not be an event access. In a simple assignment, the rightOperand must be an expression of a type that is implicitly convertible to the type of the leftOperand. It assigns the value of the rightOperand to the variable, property, or indexer element specified by the leftOperand. The result has the same type as the leftOperand and is always considered as a value type. If the leftOperand is a property or indexer access, the latter must have a set accessor. Compound assignment operators \\(\\ast \\! =, /\\!\\!=, \\%\\!=, +\\!=, -\\!=, &lt;\\!&lt;=, &gt;\\!&gt;=, \\&amp;\\!=, \\wedge\\!\\!=\\), and \\(\\vert\\!\\!=\\) are operators formed by prefixing a diadic operator with the = character. They perform the indicated operation on the leftOperand and rightOperand, and then assign the resulting value to the variable, property, or indexer element given by the leftOperand. The operators, \\(+ \\! \\!=\\) and \\(- \\! \\!=\\), with an event access expression as the leftOperand are called event assignment operators. No other assignment operator is valid with an event access as the leftOperand. Figure 3.12: AssignmentOpr.cs program run results Compound assignment operations of the form \\(a \\, \\, op = b\\) (where op is one of \\(\\ast, /, \\%, +, -, &lt; \\! &lt;, &gt; \\! &gt;, \\&amp;, \\wedge, \\vert\\)) are processed as if it is written in the form $ a = a , , op , , b$. Evaluation of \\(a\\) performed only once. This contributes to performance improvement, especially if evaluating \\(a\\) involves method calls. The program shown in Listing ?? exemplifies the various forms of the compound assignment statement. The results from running this program are shown in Figure 3.12. Line 10 prints the initial value of \\(x\\), which is equal to 10. Consider lines 12 – 16. Each line is a compound assignment statement. Once we recognize the syntactic equivalence, for example, that \\(x +\\!= 5\\) and \\(x = x + 5\\) are the same, it is easy to follow the program. Value of \\(x\\) after executing lines 12 – 16 is 15, 5, 20, 10, and 1, respectively. Hence, line 17 prints 1. The left shift operation on line 18 assigns 16 for \\(x\\) (each of the four left shifts doubles the value of \\(x\\) successively). The right shift operation on line 19 assigns 4 for \\(x\\) (each left shift halves the \\(x\\) value). Therefore, 4 is printed by line 19. Bitwise ANDing of \\(x\\) (0100) with 10 (1010) results in assigning 0 to \\(x\\) (line 25). ORing 0 (0000) with 10 (1010) entails a value of 10 to \\(x\\). Finally, XORing (exclusive OR) of \\(x\\) (1010) with 8 (1000) results in 0010 (= 2). Hence, line 24 prints 2. When the leftOperand of a compound assignment is a property access or indexer access, the property or indexer must have both a get accessor and a set accessor. 3.9 Expression Evaluation A simple expression consists of one or more operands and zero or more operators. Compound expressions are constructed by linking simple expressions with the logical connectives &amp;&amp; and \\(\\vert \\vert\\). There are three types of expressions: arithmetic, boolean, and relational. You are already familiar with arithmetic expressions. As discussed above, we use precedence and associativity rules in evaluating them deterministically. Evaluating an arithmetic expression always yields an integral value. Boolean and relational expressions are quite similar to arithmetic expressions. Operands in a boolean expression are restricted to boolean variables and boolean constants (or literals): true and false; operators are limited to !, &amp;&amp;, and \\(\\vert \\vert\\). Their evaluation should always result in a boolean value. Assuming that moreInput and done are boolean variables, the following are valid boolean expressions: moreInput, !moreInput, moreInput &amp;&amp; !done, moreInput \\(\\vert \\vert\\) done. A simple relational expression involves integral operands and integral literals, and the operands \\(&lt;\\), \\(\\leq\\), \\(&gt;\\), \\(\\geq\\), \\(= =\\), and \\(!=\\). Assuming that age and weight are variables of type integer, the following are valid relational expressions: !(age \\(&lt;\\) 20), age == 30, and age \\(\\geq\\) 10. Valid compound relational expressions are: (age \\(\\leq\\) 30) &amp;&amp; (weight \\(\\leq\\) 300), ((weight \\(\\geq\\) 120 ) &amp;&amp; (weight \\(\\leq\\) 300)). Note that, though it is not necessary, we have used parentheses to convey the intended order of evaluation explicitly. Evaluation of relational expressions should always result in a boolean value. Boolean and relational expressions can be linked using the logical connectives to form compound expressions as in: (nonSmoker &amp;&amp; ((height \\(\\geq\\) 170) \\(\\vert \\vert\\) ((weight \\(\\geq\\) 120 ) &amp;&amp; (weight \\(\\leq\\) 300)))). Boolean and relational expressions are used in conditionally executing a statement(s) and in repeatedly executing one or more statements as long as a certain condition holds (discussed in Chapter ??). 3.10 Exception Processing As you might have already encountered, errors are generated by the compiler when (syntactically) defective programs are compiled. The compiler reports syntactic errors — those that are related to the grammar violations of the language — and other errors that can be discovered at the compile-time (e.g., typecasting related errors). In contrast, runtime errors occur during the program execution. Such errors, for instance, occur when opening a non-existent file, reading data from a file, and overflow conditions in arithmetic operations. Runtime errors need to be detected (termed raising or throwing an exception) and handled appropriately (termed exception handling). Otherwise, the program crashes — an undesirable and unpleasant situation. Closely related to, but distinct from exceptions, are events. For example, end of file event occurs when the end of file is reached while reading data from the file. Like exceptions, events need to be detected and processed (discussed in Section ??). There are two categories of exceptions: system-defined and user-defined. System-defined exceptions are pre-defined ones and are automatically raised by the language runtime. User-defined or custom exceptions are discussed in Section ??. The .NET Framework provides Structured Exception Handling (SEH) — a comprehensive feature for addressing exceptions. SEH is common to all .NET-compliant languages including C#, VB.NET, and VC++.NET. Exceptions raised by the code in one .NET language can be caught and handled in the code written in another .NET language. Table 3.11 shows some system-defined exceptions. Table 3.11: Some system-defined exceptions Exception_Name Description DivideByZeroException Raised when an attempt to divide an integral value by zero occurs. OverflowException Raised when an arithmetic operation (in a checked context) overflows. FormatException Raised when the format of an argument does not meet the parameter specifications of the invoked method. ArgumentOutOfRangeException Raised when the value of an argument is outside the allowable range of values as defined by the invoked method. IndexOutOfRangeException Raised when an an array is accessed via an index that is less than zero or outside the bounds of the array. ArrayTypeMismatchException Raised when a value assigned to an array element fails because the actual type of the assigned value is incompatible with the actual type of the array. StackOverflowException Raised when the execution stack is exhausted typically due to unbounded recursion. InvalidCastException Raised when an explicit conversion from a base type or interface to a derived type fails at run time. 3.10.1 try/catch/finally Blocks We need to first introduce try/catch/finally block syntax to explain how exceptions are thrown and caught/handled. A try/catch/finally block is of the form: try { try block } catch (ExceptionClass\\(_1\\) \\(e_1\\)) { catch block\\(_1\\) statements } catch (ExceptionClass\\(_2\\) \\(e_2\\)) { catch block\\(_2\\) statements } \\(\\cdots\\) catch (ExceptionClass\\(_n\\) \\(e_n\\)) { catch block\\(_n\\) statements } \\([\\) catch ( ) { default catch block statements } \\(]\\) \\([\\) { finally block statements } \\(]\\) } It has one try block, one or more catch blocks, and an optional finally block. Note that each catch block is associated with an exception class. For example, the exception class of catch block\\(_1\\) is ExceptionClass\\(_1\\). The code that may cause run-time errors is enclosed within the try block. When pre-defined exceptional conditions arise during the processing of statements in the try block, the C# runtime system throws an exception immediately and unconditionally. For user-defined exceptions, a throw statement is used by the programmer to raise the exception (Section ??). Program control never reaches the statement immediately following the statement that resulted in a pre-defined exception or the throw statement. When an exception occurs, the run-time system searches for the nearest catch clause that can handle the exception. Matching an exception with a catch block is determined by the run-time class of the exception. For example, the class of the exception that occurred is compared with ExceptionClass\\(_1\\). If they match, the exception is handled by executing the code in catch block\\(_1\\). If the optional finally block exists, the program control is then transferred to the finally block. The program terminates after executing the statements in the finally block. This block typically contains statements for gracefully terminating the program by performing house-cleaning and resource release (e.g., releasing database connections and other system resources) activities. If there is no match, the class of the exception that occurred is compared with ExceptionClass\\(_2\\). If they match, the exception is handled by executing the code in catch block\\(_2\\) and the program control is transferred to the optional finally block as before. Successive catch block exception classes are compared with the class of the exception that occurred in the order of their physical placement until a match is found. If the optional default catch block is present (the one that is just before the finally block), and if no match is found up to this point, the default catch block is executed. Note that the default catch block doesn’t have an exception class to match. It is always a good idea to provide the default catch block so that no exception goes without being handled. The order of placement of ExceptionClasses is important. ExceptionClass\\(_1\\) is more specific than ExceptionClass\\(_2\\), and ExceptionClass\\(_2\\) is more specific than ExceptionClass\\(_3\\), and so on. Hence, the default catch block is the most general. The idea is that the more specific we are about an exception type, the more precise we can be in handling the exception. Several interesting issues arise when a method \\(m_1()\\) of class \\(C_1\\) calls method \\(m_2()\\) of class \\(C_2\\), and \\(m_2()\\) calls method \\(m_3()\\) of class \\(C_3\\). What happens when an exception is raised in \\(m_3()\\) which has a finally clause and there is no suitable catch block to handle the exception? What should \\(m_2()\\) do about this exception? If \\(m_2()\\) also doesn’t handle this exception, what should \\(m_1()\\) do? In which order should the optional finally and catch blocks be executed in this cascading scenario? Some of these issues are addressed in Section ??. 3.10.2 System-Defined Exceptions Handling Program Exceptions.cs program shown in Listing ?? exemplifies handling of system-defined exceptions. Lines 5 – 15 implement a simplified Calculator class with only two methods: Add() and Div() (see Listing ??. The Main() in Exceptions class declares three integer variables (\\(num1\\), \\(num2\\), and \\(result\\)). It also declares, creates, and initializes strArray — an array of strings. The array size (3) is implicitly specified through the values in the initializer list. Line 22 creates an instance of the Calculator class (myCalc). Lines 25 – 36 compose the try block. For the runtime system to detect exceptions, statements must be placed in the try block. Following the try block are three catch blocks (lines 38 – 55). The first catch block (lines 40 – 42) processes or handles exceptions of type OverflowException. Likewise, the catch block of lines 46 – 48 handles exceptions of type DivideByZeroException; and the catch block lines 52 – 54 processes all types of exceptions. We chose to provide the first two catch blocks so that specialized action can be taken when exceptions of that type are detected. As soon as an exception is detected in the try block, the program execution control is immediately transferred to the appropriate catch block. For example, if OverflowException is detected in the try block, the program control is transferred to the catch block of lines 38 – 43. If we didn’t have this catch block, the control would have been transferred to the generic catch block of lines 50 – 55. Therefore, catch blocks corresponding to specialized exceptions should be placed ahead of the catch blocks corresponding to the more general exceptions. Each catch block has three statements. The first one prints the exception type name by calling the GetType() method. The next two lines print values of two properties: Source and Message. Source indicates which class/object caused the exception, and Message provides descriptive information about the exception. Notice the finally keyword on line 56 and its statements (line 58). The control always gets transferred to the finally block after passing through the relevant catch block. As indicated earlier, the finally block is typically used to free up system resources and to perform house cleaning tasks (e.g., closing database connections, closing open files, flushing memory buffers) and to provide graceful exit from the error conditions. Therefore, the finally block should be placed at a strategic location to meet these objectives. Now let us trace the program execution for certain input values. The results of running the Exceptions.cs program is shown in Figure 3.13. Line 25 prompts the user to enter an integer number, and line 26 assigns this number to \\(num1\\). The value returned by Console.ReadLine() is passed to the Parse() method of Int32 class. This is needed since the value returned by Console.ReadLine() is simply a string of characters, which the Parse() interprets as an integer. This also illustrates the principle of functional composition — stringing together several functions in a way that the output of one becomes the input for another to achieve elegance and simplicity in the code. Say, we entered 4000000000 (4 billion), which is greater than the maximum value an integer (Int32) can hold (see Table 3.5. Therefore, the runtime generates OverflowException and immediately transfers the control to the catch block of lines 38 – 43 since this block is specifically for processing exceptions of this type. As can be seen from the program output (Figure 3.13, exception type (System.OverflowException), the source that caused the exception (mscorlib.dll, the library where the Console class is defined), and a descriptive message. Then the control is transferred to the finally block which simply prints out the string: Control always comes here. Rerun the program and enter 100 for the first prompt and 0 for the second one. Now \\(num1\\) is 100 and \\(num2\\) is 0. myCalc.Add() call doesn’t result in raising an exception, and line prints the sum of the two numbers. However, myCalc.Div() call results in raising DivideByZeroException since \\(num2\\) is 0. This causes the control to immediately move to the catch block specifically designed for catching this type of exception (lines 44 – 49). After printing the exception details, the control is moved to the finally block, and the program terminates. Rerun the program one more time with \\(num1\\) = 1000000 and \\(num2\\) = 2000000. Both addition and division operations don’t result in raising any exceptions. The control moves in sequence to line 34 and prints strArray element at index 0 (which is the string First). The execution of line 35 results in IndexOutOfBounds exception, since strArray[3] (which doesn’t exist) is accessed. Since none of catch blocks are specifically designed for handling this type of exception, it is caught by the last catch block (which is a generic one). In passing, Structured Exception Handling (SEH) feature of the .NET Framework provides an effective and integrated approach to uniformly detecting, raising, and handling exceptions. Prior to the days of SEH, many ad hoc approaches were used for exception handling in Windows programming. One that was widely used is based on returning error code(s) by the callee method to the caller. A major problem with this approach was not having the context to process the exception. Assume that method \\(A\\)() calls \\(B\\)(), which in turn calls \\(C\\)(). If \\(C\\)() returns an error code to \\(B\\)(), which transforms this code into some other code to account for its local factors and returns this new code to \\(A\\)(). The problem now is that \\(A\\)() doesn’t have the context in which the exception was raised in \\(C\\)(). SEH facilitates exception handling without losing the context. Separation of the code into try and catch blocks makes the code easy to understand and maintain. In mission-critical and high-availability applications, exception handling code doesn’t write to the console. Exception messages are either logged to a file, or sensed by a network management program and displayed at a central location, where they are monitored round the clock. The latter is typical in enterprise applications which are hosted in a data center. The data center monitors all exception messages routed to it from multiple programs (applications). It is important to recognize that all exceptions are objects. They are instances of classes derived from the System.Exception class (Figure 3.14. SystemException is derived from the Exception; ArithmeticException is derived from SystemException; OverflowException and DivideByZeroException are both derived from the ArithmeticException. Therefore, catch (Exception e) block (lines 51–56 of Listing ?? can be used to process all exception types in a generic way. Figure 3.13: Exceptions.cs program run results System.Exception defines three overloaded constructors (discussed in Section ??, six properties, and six methods. All system-defined exceptions are derived from the System.Exception class. User-defined exception classes are also derived from the System.Exception class and typically override the methods of the latter. They are needed in special cases to more intimately customize and address application-specific exceptions. User-defined exception class name should follow the naming convention of suffixing Exception to the class name. They should also implement all the three overloaded constructors of the System.Exception class for uniformity. User-defined exceptions are discussed in Section ??. 3.11 Chapter Summary Syntax specifies the structure of C# programs. The syntactic correctness is usually specified by a grammar. EBNF is a notation for precisely and succinctly describing the grammar. A parser is a program that validates the syntactic correctness of C# programs. You don’t directly invoke the parser; it is typically invoked by the compiler when C# programs are compiled. Semantics of a programming language describes the meaning of various constructs the language offers for program construction. There are two types of semantics: denotational and operational. Figure 3.14: Partial hierarchy of system-defined exceptions C# offers an assortment of types (both pre-defined and user-definable) to suit different needs. They are broadly grouped into value and reference types. Pre-defined value types include bool, char, decimal, integral types (byte, sbyte, short, ushort, int, uint, long, and ulong), floating point types (float, and double); user-definable value types include enum and struct; pre-defined reference types include array, string, and object; lastly, user-definable reference types include class, interface, and delegate. A value type specifies three things: the type of the value, the range of values that can be stored, and permissible operations. Variables are aliases or symbolic names for memory locations. Declaring a variable comprises naming the variable and associating a type with the variable. For efficiency and safety reasons, it is important to assign a right types to variables. Constants are special variables whose values cannot be changed once the values are assigned. Namespaces is a mechanism by which C# type name conflicts are resolved. A C# class consists of one or more of the following members: fields, constants, methods, properties, indexers, events, and operators. Access modifiers are used to control the visibility of various components of the class. One of the classes in the C# program should define the Main() method, which serves as an entry point into the program. C# features a repertoire of operators, which are grouped into categories: arithmetic, logical, relational, assignment, and conditional. The .NET Framework Class Library provides a large assortment of classes, which can be included in our programs. Several tools exist to explore the library including IL Disassembler, Windows Class Viewer, Class Browser Web Application, and Visual Studio.NET Object Browser. Exceptions are abnormal conditions that occur in a program during its execution. Such conditions need to be detected and processed to prevent a running program from crashing. Exceptions are implicitly raised in the try block and are processed in the catch block. 3.12 Exercises Define the terms syntax, semantics, and BNF. Keywords are identifiers that are reserved for special uses. True or false? Which of the following are valid identifiers? For invalid identifiers, explain why they are invalid. Age _price $loan 1bank LoanAmount CUst-Name stockID prodDesc Course# prod&amp;id Which of the following are keywords in C#? price new income int class xyz static void nill public null enum savings enumeration Identify each of the following C# types as either value type or reference type: int short ulong double byte enum char float struct decimal string class For each of the following data types, give the number of bytes allocated for storing values of the given type: char byte short int long float double decimal For each of the following data types, give the smallest and largest values that a variable of the specified data type can store: byte sbyte short ushort int uint If p = 5, q = 8, and r = 10, evaluate the following arithmetic expressions: p + q * r p + q * r % 10 (p + q) * (q - p)/5 p * q/r + q % 3 p * (q + r)/5 + r % 3 If p = 5, q = 8, and r = 10, evaluate the following logical expressions: p &lt; 5 &amp; r&gt; 10 p &lt; 5 | q == 5 p == 5 &amp; q &gt; 5 !(p &lt; 5 &amp; q &gt; 5) p &lt; 5 ^ (q &lt; 5 ^ r &gt;= 5) p &lt;= 5 &amp;! (r &gt; 10) p &gt; 5 &amp; (q &lt; 5 ^ r &gt;=5) true &amp; false | true true ^ true &amp; false !(p &gt; 5 | q &lt; 10 ) &amp; (r &gt; 5) If p = 5, q = 8, and r = 10, determine the value assigned by each of the following assignment statements: p = ++ q + r q = p++ + r++ r = –p + –q p = r++ - q– q = –r + p++ r = –p - –q p = p + q++ q = p– + r++ r = ++p + ++q p = ++r% ++q If p = 12, q = 20, and r = 30, determine the value assigned in each of the following statements: p += q + r p *= r-q q %= 3 r /= q - p r -= q - p If p = 12, q = 20, and r = 30, evaluate the following expressions: p &lt;&lt; 5b p &gt;&gt; 2 q &lt;&lt; 4 q &gt;&gt; 3e r &gt;&gt; 2 r &gt;&gt; 4 If p = 10, q = 8, and r = 6, evaluate the following bit-wise operators: p &amp; q q | r p ^ q p &amp; q &amp; r p &amp; q | r p | q &amp; r q ^ r p | q ^ r p | q | r q &amp; r If p = 10, q = 8, and r = 6, determine the value assigned in each of the following assignment statements: p = r &lt; 10 ? q + 2 : q - 2 p = q &gt; ? 5 : 15 p = q &lt; 5 ? r * 2 : q * 3 p = r &gt; 10 ? q % 2 : p % 3 p = q &gt; 5 ? q / 2 : r / 3 If p = 10, q = 8, and r = 6, evaluate the following expressions: p &lt; 5 &amp;&amp; r &gt; 10 p &lt; 5 || q == 5 p == 5 &amp;&amp; q &gt; 5 !(p &lt; 5 &amp;&amp; q &gt; 5) p &gt; 5 &amp;&amp; (q &lt; 5 || r &gt;=5) p &lt;= 5 &amp;&amp; !(r &gt; 10) p &gt; 5 &amp;&amp; (q &lt; 5 || r &gt;= 5) !(p &gt; 5 || q &lt; 10) &amp;&amp; (r &gt; 5) Which of the following are valid variable/constant declarations? Give explanation for each invalid declaration. int x, y, z; int x = 10, y = 10.5; const float pi = 3.14156; double price = 150.99; char ch = “X”; string strMsg = “Peace”; public const int count; private static int multiplier = 15.75; protected char gender = ‘M’; public bool flag = TRUE; Match each item on the left with its meaning on the right. void - left shift operator using directive - Indicate that a method does not return a value int - Logical OR operator Main - Permit the use of types in a namespace &lt;&lt; - Modulus operator &amp;&amp; - Keyword used to declare a scope private - Short-circuit logical AND operator namespace - Access modifier | - integer Data Type % - Method Name Identify and fix errors in the following program: using System; namespace TestApp { public class Test { public static void Main(string[ ] args) { int x, y; x = 10; y = 15.0; Console.WriteLine(“x = {0} y = {1}”, x, y); return x + y; } } } Identify and fix the errors in the following program: using System; namespace TestApp { public class Test { public const double PI; public string greeting = ’Hello!’; public static int Main(string[ ] args) { int f = 3 * PI; Console.WriteLine(f); return; } } } Identify and fix the errors in the following program: using System; namespace TestApp { public CLASS Test { public static VOID Main() { char ch = “Doe”; int x = 10 + 15.75; Console.WriteLine(“ch = {0} x = {1}”, ch, x); } } } What output is generated by the following program? using System; namespace TestApp { public class Test { public static void Main() int x = 4, y = 6; int p = 8, q = 10, r = 12; x += y; y *= x; p /= 2; r %= 5; q -= x / 3; Console.WriteLine(“x = {0} y = {1} p = {2} q = {3} r = {4}“, x, y, p, q, r); } } } What output is generated by the following program? using System; namespace TestApp { public class Test { public static void Main() { int x, y, z; int p = 8, q = 10, r = 12; x = p &amp; q j r; y = p j q &amp; r; z = p &amp; q ^ r; Console.WriteLine(“x = {0} y = {1} z = {2}”, x, y, z); } } } What output is generated by the following program? using System; namespace TestApp { public class Test { public static void Main() { int x = 50, y = 25; x = x &lt;&lt; 3; y = x &gt; 100 ? x - y : x + y; y = y &gt;&gt; 5; Console.WriteLine(“x = {0} y = {1}”, ++x, y); } } } What output is generated by the following program? using System; namespace TestApp { public class Test { public static void Main() { int x, y, z; int p = 8; q = 10; r = 12; x = ++p + q++; y = ++x * r++ - p–; z = –p + y– * q++; Console.WriteLine(“x = {0} y = {1} z = {2}”, x, y, z); Console.WriteLine(“p = {0} q = {1} r = {2}”, p, q, r); } } } What output is generated by the following program? using System; namespace TestApp { public class Test { public static void Main() { int x; bool b1, b2, b3; int p = 8; q = 10; r = 12; x =p &lt; 10 ? q + 2 : r - 2; b1 =x &lt; 10 &amp;&amp; q &gt; 5; b2 =r &gt; 10 ? true : false; b3 =b1 || b2 &amp;&amp; (p + q &lt; r ); Console.WriteLine(“x = {0}”, x); Console.WriteLine(“b1 = {0} b2 = {1} b3 = {2}”, b1, b2, b3); } } } Name any five predefined system exceptions. What output is generated by the following program? using System; namespace TestApp { public class Test { public static void Main() { int x =10;y = 0; z =0; try { z =x/y; } catch (System.DivideByZeroException ex) Console.WriteLine(“Division by zero is not allowed!”); } catch (System.Exception ex) { Console.WriteLine(“Sorry, an exception occurred!”); } Console.WriteLine(“x = {0} y = {1} z = {2}”, x, y, z); } } } What output is generated by the following program? using System; namespace TestApp { public class Test { public static void Main() { int x =10;y =0; z =0; try { z =x/y; Console.WriteLine(“x = {0} y = {1} z = {2}”, x, y, z); } catch (System.DivideByZeroException ex) { Console.WriteLine(“Division by zero is not allowed!”); } catch (System.Exception ex) { Console.WriteLine(“Sorry, an exception occurred!”); } } } } What output is generated by the following program? using System; namespace TestApp { public class Test { public static void Main() { int x =10;y =0; z =0; try { z =x/y; } catch (System.DivideByZeroException ex) { Console.WriteLine(“Division by zero is not allowed!”); } catch (System.Exception ex) { Console.WriteLine(“Sorry, an exception occurred!”); } finally { Console.WriteLine(“x = {0} y = {1} z = {2}”, x, y, z); } } } } What output is generated by the following program? using System; namespace TestApp { public class Test { public static void Main() { int x =10;y =5; z =0; try { z = x/y; } catch (System.DivideByZeroException ex) { Console.WriteLine(“Division by zero is not allowed!”); } catch (System.Exception ex) { Console.WriteLine(“Sorry, an exception occurred!”); } finally { Console.WriteLine(“x = {0} y = {1} z = {2}”, x, y, z); } } } } What operator is used to create an instance of a class? Write get and set methods for member variables, declared as shown below, of a class that describes a product: private int quantity; private string description; private float price; Figure 3.15: Exploring UInt16 class 3.13 Programming Projects As shown in Table 3.5, most of the C# intrinsic data types alias System data types. The latter are derived from ValueType class. Use a Class Viewer or Class Browser Web application to examine the System data types (Figure 3.15). Note that UInt16 data type has two static constants: MaxValue and MinValue, which specify the range of values the data type can store. It has various methods including CompareTo(), Equals(), GetType(), GetHashCode(), Parse(), and ToString(). Write a program to print MaxValue and MinValue of various System types to the console. The program should also demonstrate how the above methods can be used. Write a program that reads two integer numbers and outputs their sum, difference, product, and quotient. Write a program that converts Fahrenheit degrees to Celsius degrees. Use the formula \\(*Celsius* = 5.0 (*Fahrenheit* - 32.0) / 9.0\\) for conversion. Input the Fahrenheit temperature as a double type value. Output the computed Celsius temperature as a double value. Write a program that reads the radius of a circle and computes and displays the area and circumference of the circle. Use a C# constant declaration to represent the value, 3.1415, of \\(\\pi\\). Write a program that reads the length and the width of a rectangle and computes the area and the perimeter of that rectangle. Display the length, width, and the computed area and perimeter. Write a program that inputs number of seconds and converts it to an equivalent number of hours, minutes, and seconds. Use division and modulus operators to accomplish this. An example output is: 4540 seconds = 1 hour, 15 minutes, 40 seconds Write a program that reads principal amount, rate of interest, and length of time in years, and computes simple interest using the formula interest = principal \\(\\ast\\) rate \\(\\ast\\) time. Display the computed interest. Write a program that reads hourly pay rate and hours worked. Compute and display the gross pay, taxes paid, and net pay. Use 10% as rate of tax. Write a program that reads distance travelled in miles during a trip, miles per gallon, and the cost of gas per gallon. Compute and display the cost of the trip. Write a program that reads a four digit number and displays the digits in the number one per line. Use division and modulus operators to accomplish this. For example, the number 4523 will be displayed as follows: 4 5 2 3 Write a program that reads the first name and the last name of a person and displays the output as follows (if John and Doe are input as first name and last name): Hello John Doe, Welcome to the world of C# and .NET! Write a program that reads the values of constants \\(a, b\\), and \\(c\\) of a quadratic equation of the form \\(ax^2 + bx + c = 0\\). Compute and display the roots of the quadratic equation. Use the following formulae to compute the roots: \\(\\mbox{root}_1 = \\frac{-b + \\sqrt{b^2 - 4ac}}{2a}\\) and \\(\\mbox{root}_2 = \\frac{-b -\\sqrt{b^2 - 4ac}}{2a}\\) Write a program that reads the value of the variable \\(x\\) in the polynomial \\(7x^2 + 4x + 5\\) and displays the value of the polynomial. Write a class named Product with the following member variables with private access level: id, name, and price. Provide public get and set methods for each of these member variables. Equip your class definition with a Main method which creates an instance of the Product class, sets each of its member fields, and displays the product details by invoking the appropriate get methods. How many bits comprise one memory location is not relevant for this discussion.↩ Technically, for reference types used as method parameters, storage is allocated both on the stack and heap. The storage allocated on the stack stores a pointer to the corresponding storage on the heap.↩ This is done for illustration purpose only. For the C# compiler, the program is just a string of characters without any formatting.↩ However, there are exceptions to this rule. There are three Marlboros in NJ.↩ The significance of static access modifier of a method will become apparent to you after we discuss instantiating classes in Section 3.10.↩ "],
["control-structures.html", "4 Control Structures 4.1 Concept Map 4.2 Preview of Arrays 4.3 Enumerations 4.4 Sequence 4.5 Selection 4.6 Iteration 4.7 Choosing the Right Control Structure 4.8 Debbuging Strategies 4.9 Chapter Summary 4.10 Exercises 4.11 Programming Projects", " 4 Control Structures 4.1 Concept Map 4.2 Preview of Arrays 4.3 Enumerations 4.4 Sequence 4.5 Selection 4.5.1 if 4.5.2 if/else 4.5.3 if/else if 4.5.4 switch 4.6 Iteration 4.6.1 for 4.6.2 foreach 4.6.3 break and continue 4.6.4 Nested for Loops 4.6.5 while 4.6.6 do/while 4.6.7 Nested while Loops 4.7 Choosing the Right Control Structure 4.8 Debbuging Strategies 4.9 Chapter Summary 4.10 Exercises 4.11 Programming Projects "],
["the-net-framework.html", "5 The .NET Framework 5.1 Concept Map 5.2 Goals of the .NET Framework 5.3 Building Blocks of the .NET Framework 5.4 Assemblies: The Building Blocks of the .NET Framework 5.5 Managed Execution Process 5.6 Application Domains 5.7 Namespace and the FLC class 5.8 Framework Utilities 5.9 Developing Programs Using Visual Studio.Net 5.10 Visual Studio .NET GUI Debugger 5.11 Chapter Summary 5.12 Exercises", " 5 The .NET Framework 5.1 Concept Map 5.2 Goals of the .NET Framework 5.3 Building Blocks of the .NET Framework 5.3.1 Common Language Runtime (CLR) 5.3.2 Framework Class Library (FCL) 5.3.3 Common Language Specification (CLS) 5.4 Assemblies: The Building Blocks of the .NET Framework 5.4.1 Single- and Multi-file Assemblies 5.4.2 Static and Dynamic Assemblies 5.4.3 Private and Shared Assesmblies 5.5 Managed Execution Process 5.6 Application Domains 5.7 Namespace and the FLC class 5.8 Framework Utilities 5.8.1 IL Disassembler Utility 5.8.2 Window Class Viewer Utility 5.8.3 ClassBrowser Web Application 5.8.4 Visual Studio .NET Object Browser 5.9 Developing Programs Using Visual Studio.Net 5.10 Visual Studio .NET GUI Debugger 5.11 Chapter Summary 5.12 Exercises "],
["object-oriented-analysis-and-design.html", "6 Object-Oriented Analysis and Design 6.1 COncept Map 6.2 Object-Oriented Analysis (OOA) 6.3 Object-Oriented Design (OOD) 6.4 Object-Oriented Programming 6.5 Software Design Pattern 6.6 Software-intensive System 6.7 System Development Life Cycle and Development Methodologies 6.8 Chapter Summary 6.9 Exercises", " 6 Object-Oriented Analysis and Design 6.1 COncept Map 6.2 Object-Oriented Analysis (OOA) 6.2.1 Problem Statement 6.2.2 Understand the Problem Domain 6.2.3 Use Case and Use Case Diagrams 6.2.4 System and its Boundary 6.2.5 Conceptual Class Model 6.2.6 OOA Checklist and Metrices 6.3 Object-Oriented Design (OOD) 6.3.1 A Multi-layer Reference Architecture 6.3.2 Determining Design Class 6.3.3 Identifying Design Class Attribute 6.3.4 Identifying Design Class Methods 6.3.5 Identifying Design Class Relationships 6.3.6 Assessing Design Class 6.4 Object-Oriented Programming 6.5 Software Design Pattern 6.5.1 Expert 6.5.2 Creator 6.5.3 Low Coupling 6.5.4 High Cohesion 6.5.5 Control 6.5.6 Facade 6.5.7 Mediator 6.6 Software-intensive System 6.6.1 Software System Goals 6.6.2 Principle for Managing Complexity 6.7 System Development Life Cycle and Development Methodologies 6.7.1 Waterfall Model 6.7.2 Evolutionary Model 6.7.3 Formal Methods 6.7.4 Component-Based Models 6.7.5 Unified Process and its Variants 6.8 Chapter Summary 6.9 Exercises "],
["classes.html", "7 Classes 7.1 Concept Map 7.2 Class Components 7.3 Class Declaration and Instantiation 7.4 Fields Declaration and Field Modifiers 7.5 Value and Reference Types 7.6 Methods 7.7 Implementing Aggregation and Composition 7.8 Structures 7.9 The Object Class 7.10 Boxing and Unboxing 7.11 Chapter Summary 7.12 Exercises 7.13 Programming Projects", " 7 Classes 7.1 Concept Map 7.2 Class Components 7.3 Class Declaration and Instantiation 7.4 Fields Declaration and Field Modifiers 7.4.1 Declaring a Field 7.4.2 Field Modifiers 7.5 Value and Reference Types 7.6 Methods 7.6.1 Method Declaration and Method Modifiers 7.6.2 Constructors 7.6.3 Destructors 7.6.4 Properties 7.6.5 Parameter Passing Techniques 7.6.6 Method Overloading 7.7 Implementing Aggregation and Composition 7.7.1 Aggregation 7.7.2 Composition 7.8 Structures 7.9 The Object Class 7.10 Boxing and Unboxing 7.11 Chapter Summary 7.12 Exercises 7.13 Programming Projects "],
["class-inheritance-and-polymorphism.html", "8 Class Inheritance and Polymorphism 8.1 Concept Map 8.2 Inheritance 8.3 Overriding Base Class Methods 8.4 Leveraging Base Class Methods in Derived Classes 8.5 Abstract Methods, Properties, and Classes 8.6 Hiding Base Class Members 8.7 Sealed Classes 8.8 Class Type Casting 8.9 Polymorphism 8.10 Chapter Summary 8.11 Exercises 8.12 Programming Projects", " 8 Class Inheritance and Polymorphism 8.1 Concept Map 8.2 Inheritance 8.2.1 Inheriting from a Base Class with Private Fields 8.2.2 Inheriting from a Base Class with Protected Fields 8.3 Overriding Base Class Methods 8.3.1 Virtual Methods and virtual Modifier 8.3.2 Overriding Virtual Methods Using override Modifier 8.4 Leveraging Base Class Methods in Derived Classes 8.4.1 Illustration of base Keyword 8.5 Abstract Methods, Properties, and Classes 8.6 Hiding Base Class Members 8.7 Sealed Classes 8.8 Class Type Casting 8.9 Polymorphism 8.9.1 Polymorphism With Base Classes Containing Virtual Methods 8.9.2 Polymorphism With Abstract Base Classes 8.10 Chapter Summary 8.11 Exercises 8.12 Programming Projects "],
["arrays.html", "9 Arrays 9.1 Concept Map 9.2 Array Characteristics 9.3 One-Dimensional Arrays 9.4 Multi-dimensional Arrays 9.5 Jagged Arrays 9.6 Arrays as Method Parameters 9.7 System.Array Base Class 9.8 Sorting and Searching 9.9 Processing Command Line Arguments 9.10 Chapter Summary 9.11 Exercises 9.12 Programming Projects", " 9 Arrays 9.1 Concept Map 9.2 Array Characteristics 9.3 One-Dimensional Arrays 9.3.1 Creating and Initializing One-Dimensional Arrays 9.3.2 Programming With One-Dimensional Arrays 9.4 Multi-dimensional Arrays 9.4.1 Creating and Initializing Two-Dimensional Arrays 9.4.2 Programming with Two-Dimensional Arrays 9.4.3 Matrices: An Application of Two-Dimensional Array 9.5 Jagged Arrays 9.6 Arrays as Method Parameters 9.6.1 Passing Arrays By Value 9.6.2 Passing Arrays By Reference 9.6.3 Passing Arrays By Out 9.6.4 Array Parameter Passing Program 9.7 System.Array Base Class 9.8 Sorting and Searching 9.8.1 Bubble Sort 9.8.2 Selection Sort 9.8.3 Insertion Sort 9.8.4 Linear Search 9.8.5 Binary Search 9.8.6 Recursive Binary Search 9.9 Processing Command Line Arguments 9.10 Chapter Summary 9.11 Exercises 9.12 Programming Projects "],
["strings.html", "10 Strings 10.1 Concept Map 10.2 Schemes for Representing Characters 10.3 The Char Class 10.4 Immutable Strings: System.String Class 10.5 Mutable Strings: System.StringBuilder class 10.6 Pattern Matching and .NET Regular Expressions 10.7 Encoding and Decoding of Unicode 10.8 Chapter Summary 10.9 Exercises 10.10 Programming Projects", " 10 Strings 10.1 Concept Map 10.2 Schemes for Representing Characters 10.3 The Char Class 10.3.1 System.Char Class Members 10.3.2 Programmatic Illustration of System.Char Class Members 10.4 Immutable Strings: System.String Class 10.4.1 Operations on Strings 10.4.2 Programmatic Illustration of String Operations 10.4.3 Verbatim Strings 10.4.4 An Application of Immutable Strings 10.5 Mutable Strings: System.StringBuilder class 10.5.1 An Application of StringBuilder Class 10.6 Pattern Matching and .NET Regular Expressions 10.6.1 .NET Classes for Regular Expressions 10.6.2 A Program to Demonstrate Regular Expressions 10.7 Encoding and Decoding of Unicode 10.8 Chapter Summary 10.9 Exercises 10.10 Programming Projects "],
["input-and-output.html", "11 Input and Output 11.1 Concept Map 11.2 The Stream Concept 11.3 System.IO Namespace 11.4 Simple Console Input and Output 11.5 Console Formatted Output 11.6 Directory Creation and Navigation 11.7 Files Creation and Manipulation 11.8 Improving I/O Performance: BufferedStream Class 11.9 Binary Files: BinaryWriter and BinaryReader Classes 11.10 StreamReader and StreamWriter Classes 11.11 StringReader and StringWriter Classes 11.12 Chapter Summary 11.13 Exercises 11.14 Programming Projects", " 11 Input and Output 11.1 Concept Map 11.2 The Stream Concept 11.3 System.IO Namespace 11.4 Simple Console Input and Output 11.5 Console Formatted Output 11.6 Directory Creation and Navigation 11.6.1 DirectoryInfo Class 11.6.2 Directory Class 11.7 Files Creation and Manipulation 11.7.1 FileInfo Class 11.7.2 File Class 11.7.3 FileStream Class 11.7.4 MemoryStream Class 11.8 Improving I/O Performance: BufferedStream Class 11.9 Binary Files: BinaryWriter and BinaryReader Classes 11.10 StreamReader and StreamWriter Classes 11.11 StringReader and StringWriter Classes 11.12 Chapter Summary 11.13 Exercises 11.14 Programming Projects "],
["interfaces.html", "12 Interfaces 12.1 Concept Map 12.2 Interface polymorphism and Abstract Classes 12.3 An Interface Implementation 12.4 Interface Reference 12.5 Interface Reference as Method Parameter 12.6 Implementing Multiple Interfaces 12.7 Interface Inheritance 12.8 Explicit Interface Implementation 12.9 Explicit Implementation of Multiple Interfaces 12.10 Core Interfaces in .NET 12.11 Chapter Summary 12.12 Exercises 12.13 Programming Projects .", " 12 Interfaces 12.1 Concept Map 12.2 Interface polymorphism and Abstract Classes 12.3 An Interface Implementation 12.4 Interface Reference 12.5 Interface Reference as Method Parameter 12.6 Implementing Multiple Interfaces 12.7 Interface Inheritance 12.8 Explicit Interface Implementation 12.9 Explicit Implementation of Multiple Interfaces 12.10 Core Interfaces in .NET 12.10.1 ICloneable 12.10.2 IComparable 12.10.3 IComparer 12.10.4 IEnumerable 12.10.5 IEnumerator 12.11 Chapter Summary 12.12 Exercises 12.13 Programming Projects . "],
["algorithm-problem-solving.html", "13 Algorithm Problem Solving 13.1 What is Algorithmic Problem Solving? 13.2 Algorithmic Concepts 13.3 Combinatorial Problem Solving 13.4 Logic 13.5 Proof Techniques 13.6 Analyzing an Algorithm 13.7 Asymptotic Analysis of Algorithms 13.8 Brute-force Algorithms 13.9 Algorithm Design Techniques 13.10 Recursion 13.11 Concept Inventory 13.12 Chapter Summary 13.13 Exercises 13.14 Programming Projects", " 13 Algorithm Problem Solving 13.1 What is Algorithmic Problem Solving? 13.1.1 Understand the Problem 13.1.2 Devise a Plan 13.1.3 Execute the Plan 13.1.4 Review and Discuss the Solution 13.2 Algorithmic Concepts 13.2.1 Characteristics of an Algorithm 13.2.2 Describing Algorithms 13.3 Combinatorial Problem Solving 13.3.1 Permutations 13.3.2 Combinations 13.3.3 Binomial Coefficients 13.4 Logic 13.4.1 Propositional Logic 13.4.2 Predicate Logic 13.5 Proof Techniques 13.5.1 Direct Proof 13.5.2 Contradiction 13.5.3 Contrapositive 13.5.4 Dirichlet’s Pigeonhole Principle 13.5.5 Mathematical Induction 13.6 Analyzing an Algorithm 13.6.1 Time and Space Requirements 13.6.2 Counting of Operations 13.6.3 Average-Case Analysis 13.6.4 Best-Case Analysis 13.6.5 Worse-Case Analysis 13.7 Asymptotic Analysis of Algorithms 13.7.1 Constant Time Complexity 13.7.2 Logarithmic Time Complexity 13.7.3 Polynomial Time Complexity 13.7.4 Exponential Time Complexity 13.7.5 Rate of Growth 13.7.6 O (Big Oh) Notation 13.7.7 (Big Theta) Notation 13.7.8 (Big-Omega) Notation 13.8 Brute-force Algorithms 13.9 Algorithm Design Techniques 13.9.1 Divide-and-Conquer 13.9.2 Greedy Algorithms 13.10 Recursion 13.10.1 Implementation of Recursion 13.10.2 Iterative vs. Recursive Solutions 13.10.3 The Towers of Hanoi 13.10.4 Solving the Recurrence T(n)= 2T (n-1) + 1 13.10.5 When is Recursion Appropriate? 13.11 Concept Inventory 13.12 Chapter Summary 13.13 Exercises 13.14 Programming Projects "],
["advanced-c-constructs.html", "14 Advanced C# Constructs 14.1 Indexers 14.2 User-defined Exceptions 14.3 Delegates 14.4 Events 14.5 Reflection: Runtime Type Discovery 14.6 Assembly Class 14.7 Attribute-Based Programming 14.8 Object Persistence and Serialization 14.9 Threads", " 14 Advanced C# Constructs 14.1 Indexers 14.2 User-defined Exceptions 14.3 Delegates 14.4 Events 14.5 Reflection: Runtime Type Discovery 14.6 Assembly Class 14.7 Attribute-Based Programming 14.8 Object Persistence and Serialization 14.8.1 Serialization Using Binary and SOAP Formatters 14.8.2 Customizing Serialization 14.9 Threads 14.9.1 Primary and Secondary Threads 14.9.2 Critical Sections and Mutual Exclusion 14.9.3 ReaderWriterLock for Mutual Exclusion 14.9.4 Producer and Consumer Synchronization "],
["data-representation.html", "15 Data Representation 15.1 Bits, Bytes, and Words 15.2 Number Bases 15.3 Representing Signed Integer Numbers 15.4 Fixed Point and Floating Point Numbers 15.5 Non-decimal Arithmetic 15.6 Packed Data 15.7 Binary Coded Decimal (BCD) Representation 15.8 Character Codes 15.9 Logical Operations on Binary Strings 15.10 Chapter Summary 15.11 Exercises", " 15 Data Representation 15.1 Bits, Bytes, and Words 15.2 Number Bases 15.3 Representing Signed Integer Numbers 15.3.1 Zero and Sign Extension 15.4 Fixed Point and Floating Point Numbers 15.4.1 Decimal Fractions 15.4.2 Representing Fixed- and Floating Point Numbers 15.5 Non-decimal Arithmetic 15.6 Packed Data 15.7 Binary Coded Decimal (BCD) Representation 15.8 Character Codes 15.9 Logical Operations on Binary Strings 15.10 Chapter Summary 15.11 Exercises "],
["computer-organization.html", "16 Computer Organization 16.1 Logic Gates and Logic Structures 16.2 Components and Organization of a Computer 16.3 Instruction Set 16.4 Addressing Modes 16.5 Instruction Execution 16.6 Chapter Summary 16.7 Exercises", " 16 Computer Organization 16.1 Logic Gates and Logic Structures 16.1.1 Inverter 16.1.2 AND Gate 16.1.3 OR Gate 16.1.4 NAND and NOR Gates 16.1.5 XOR and XNOR Gates 16.1.6 Multiplexers 16.1.7 Binary Adders 16.1.8 Clock 16.1.9 Flip-flops 16.1.10 Registers 16.1.11 Circuit and Chip Design 16.2 Components and Organization of a Computer 16.2.1 CPU 16.2.2 Memory 16.2.3 Registers 16.2.4 Cache Memory 16.2.5 Primary Memory 16.2.6 Secondary and Tertiary Memory 16.2.7 I/O Devices 16.2.8 Bus 16.3 Instruction Set 16.4 Addressing Modes 16.4.1 An Assembly Language Program 16.4.2 Immediate and Indirect Addressing Mode 16.4.3 Indexed Addressing Mode 16.5 Instruction Execution 16.5.1 Memory Read and Write Operations 16.5.2 Register to Register Data Transfer 16.5.3 ALU Operations 16.5.4 Instruction Fetch and Execution Cycles 16.5.5 Branching 16.5.6 Hardwired Implementation of Control Unit 16.5.7 Microprogrammed Implementation of Control Unit 16.6 Chapter Summary 16.7 Exercises "]
]
